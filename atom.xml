<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fun&#39;s biog</title>
  <icon>https://www.gravatar.com/avatar/f39861afab14da52441a9aed4ddc5e01</icon>
  <subtitle>一个只会搬砖，不会写博客的不入流程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrnoknow.github.io/"/>
  <updated>2019-03-18T07:53:04.659Z</updated>
  <id>https://mrnoknow.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 视频播放自定义布局</title>
    <link href="https://mrnoknow.github.io/2018/01/19/Android-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/"/>
    <id>https://mrnoknow.github.io/2018/01/19/Android-视频播放自定义布局/</id>
    <published>2018-01-19T07:40:57.000Z</published>
    <updated>2019-03-18T07:53:04.659Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中，会遇到这样一个问题，需要在App中添加一个视频，但是功能又不需要很复杂，如果我们导入一个很大的视频库的话，会增加我们App的size，所以我们就需要自制一个简易的视频，并且可以自定义它的样式。<br>接下来就介绍一下怎样快速的自己写一个可自定义样式的视频。</p><h5 id="VideoView（Android封装的播放器）"><a href="#VideoView（Android封装的播放器）" class="headerlink" title="VideoView（Android封装的播放器）"></a>VideoView（Android封装的播放器）</h5><p>我们先看看Android自带的视频播放器，VideoView就是AndroidAPI中的自带视频播放器，其设计有以下几点：</p><ul><li>VideoView继承SurfaceView</li><li>VideoView用的视频播放器是Android自带的MediaPlayer</li><li>控制VideoView播放器视图的是MediaController，控制一些基本的操作的视图，比如快进，后退，播放占等播放状态</li></ul><p>所以如果我们不需要自定义视图，且功能非常的简单，我们就直接可以使用VideoView播放器</p><p><strong>在VideoView中，需要明白的是SurfaceView，MediaController和MediaPlayer各个标注位，SurfaceView是承接MediaPlayer的视图，MediaController是控制MediaPlayer的视图</strong><br>所以我们自定义视频播放器的话，也可以按照这个思路来，播放器继承SurfaceView，在写一个控制视图。其实我在想为什么不设计一个小的库，然后我们直接写一个布局传进去，然后就能得到我们想要的播放的样式，这个难点<br>就是我们传进去的视图组件需要绑定监听啊，所以这点还是我现在无法想到解决办法的，所以我们可以实现一个播放视图，然后自己实现一个控制视图去控制它，所以我们只要把这个思路搞清楚其实就是码代码的事情和对一些逻辑<br>标志位的处理就行了，还有就是对Android各个自定义系统的适配问题了，因为视频这个问题很多坑。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>这里先整理一下这个视频的整个逻辑<br>先要知道的是几个逻辑点：</p><ul><li>连接wifi自动播放</li><li>连接流量出现播放按钮，不自动播放</li><li>无网状态：<ul><li>在开始加载状态突然无网，一直出现加载loading</li><li>播放状态无网，播放到加载处，暂停，记录暂停位置，然后出现无网logo</li><li>播放状态无网，拖动进度条。直接出现无网logo，暂停，记录暂停位置</li></ul></li><li>点击无网状态logo，判断是否连接网络，若有网络，直接加载，否则还显示无网logo</li><li>加载loading的出现时机与消失时机，在开始时出现。在拖动进度条，若是没有被加载，则出现loading，否则不显示loading，API版本不同的适配</li><li>前后台切换，对视频状态的保存和恢复，以及不同Android平台的适配，这个坑太多</li></ul><p>以上大概就是视频播放的一些必要点，虽然看着这个逻辑不是很多，但是要把这些点串起来，并且去适配各种不同的平台和API还是有很多东西需要考虑的</p><p>上面这张图就是一个网络视频播放器的简单流程图。</p><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><ul><li>WMVideoGesture：手势操作类</li><li>IController：WMVideoController绑定Activity生命周期接口</li><li>ControllerChangeView：视图控件显示隐藏接口</li><li>WMMediaInterface：视频播放生命周期接口</li><li>WMVideoController：控制视频的视图，继承WMVideoGesture</li><li>WMVideoView：视频实现类，内部是MediaPlayer，继承SurfaceView，实现WMMediaInterface接口</li></ul><h4 id="逻辑细节梳理"><a href="#逻辑细节梳理" class="headerlink" title="逻辑细节梳理"></a>逻辑细节梳理</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android开发中，会遇到这样一个问题，需要在App中添加一个视频，但是功能又不需要很复杂，如果我们导入一个很大的视频库的话，会增加我们App的size，所以我们就需要自制一个简易的视频，并且可以自定义它的样式。&lt;br&gt;接下来就介绍一下怎样快速的自己写一个可自定义样式的
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>Reduce APK Size</title>
    <link href="https://mrnoknow.github.io/2017/12/14/Reduce-APK-Size/"/>
    <id>https://mrnoknow.github.io/2017/12/14/Reduce-APK-Size/</id>
    <published>2017-12-14T08:14:41.000Z</published>
    <updated>2019-03-18T07:53:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Android工程中，要尽量减少APK的大小，提高性能</p><h3 id="理解Apk的结构"><a href="#理解Apk的结构" class="headerlink" title="理解Apk的结构"></a>理解Apk的结构</h3><ul><li><p><code>META-INF/</code>:包含<code>CERT.SF</code>和<code>CERT.RSA</code>签名文件，还包括<code>MANIFEST.MF</code>的文件清单</p></li><li><p><code>assets/</code>:直接打包进APK的资源，不会直接在<code>R.java</code>生成资源ID，可使用<a href="https://developer.android.google.cn/reference/android/content/res/AssetManager.html" target="_blank" rel="noopener">AssetManager</a>来对它进行引用使用</p></li><li><p><code>res/</code>:包含不编译成<code>resources.arsc</code>的资源</p></li><li><p><code>lib/</code>:包含不同处理器的编译代码，包含各个平台类型，比如<code>armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, and mips.</code></p><p><strong>APK还包含以下几个部分，除了<code>AndroidManifest.xml</code>是必须的，其他都是不强制的</strong></p></li><li><p><code>resources.arsc</code>:包含所有配置的XML内容来自<code>res/values/</code>文件夹，通过工具获取XML内容，然后编译二进制文件，然后归档内容,内容包括字符串和样式，但是不包括内容的路径，例如布局文件和图片</p></li><li><p><code>classes.dex</code>:包含通过<strong>Dalvik/ART</strong>虚拟机编译java源码生成的DEX文件</p></li><li><p><code>AndroidManifest.xml</code>:包含核心的Android清单文件，此文件包含应用的名称，权限，版本，引用的库。此文件是二进制文件</p></li></ul><h3 id="减少资源文件的数量和大"><a href="#减少资源文件的数量和大" class="headerlink" title="减少资源文件的数量和大"></a>减少资源文件的数量和大</h3><p><em>APK的大小会影响APP的性能，如加载速度，内存的使用，以及电力的消耗。一个很常见的减少APK大小的方法就是减少资源文件的数量和大小，比如，你可以移除不在使用的资源，使用可以扩展的<a href="https://developer.android.google.cn/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="noopener">Drawable</a>对象来代替图像文件，所以接下来就是讨论怎样减少资源文件的数量和大小</em></p><h5 id="删除不使用的资源文件"><a href="#删除不使用的资源文件" class="headerlink" title="删除不使用的资源文件"></a>删除不使用的资源文件</h5><ul><li><p><a href="https://developer.android.google.cn/studio/write/lint.html" target="_blank" rel="noopener">lint</a>工具是AS中自带的静态代码分析器，检测<code>res/</code>文件下没有被引用的资源，当检测发现了没有被引用的资源后会输出像以下的警告。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res/layout/preferences.xml: Warning: The<span class="built_in"> resource </span>R.layout.preferences appears</span><br><span class="line">  <span class="keyword">to</span> be unused [UnusedResources]</span><br></pre></td></tr></table></figure><p><strong>但是Lint工具无法扫描检测<code>assets/</code>文件夹，因为此文件夹下的是通过反射引用的资源或者是链接的库文件，所以它是不可以的移除的资源，它只会存在一个提醒</strong><br><code>Libraries</code>代码库中也可能存在不被使用的情况,<code>Gradle</code>可以自动的移除这些无用的资源当你在<code>build.gradle</code>文件中配置<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">shrinkResources</a>。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">  // Other <span class="keyword">settings</span></span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">      release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          shrinkResources <span class="keyword">true</span></span><br><span class="line">          proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">shrinkResources</a>，就必须使用代码压缩，在构建的过程中，<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">ProGuard</a>会首先移除未使用的代码但不会移除未使用的资源，之后<code>Gradle</code>会移除未使用的资源，（关于ProGuard和其他方法的来压缩代码和资源可学习此文章<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">Shrink Your Code and Resources</a>）</p></li></ul><h5 id="减少资源库"><a href="#减少资源库" class="headerlink" title="减少资源库"></a>减少资源库</h5><ul><li>在开发中我们肯定会使用外部库来提高我们应用的可用性，所以<a href="https://developer.android.google.cn/topic/libraries/support-library/index.html" target="_blank" rel="noopener">库</a>中会包含很多对象和方法是不需要，所以如果许可证认可，可以去动态的编辑库文件，增加删除库文件，来定制自己的APP内容，<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">ProGuard</a>可以移除不使用的库中代码，但是它不能够移除库中的内部依赖项</li></ul><h5 id="支持特定的屏幕密度"><a href="#支持特定的屏幕密度" class="headerlink" title="支持特定的屏幕密度"></a>支持特定的屏幕密度</h5><ul><li>若只有一小部分的用户使用，则需要特殊处理，如果你APP中不包含这些特定的<a href="https://developer.android.google.cn/about/dashboards/index.html#Screens" target="_blank" rel="noopener">屏幕密度</a>，android会自动缩放现有的资源。如果你需要自动缩放的资源，你可以通过绘制图像的变种放置<code>drawable-nodpi/</code>来节省空间，我们建议至少存在一个<code>xxhdpi</code>的图片变种</li></ul><h5 id="使用Drawable对象"><a href="#使用Drawable对象" class="headerlink" title="使用Drawable对象"></a>使用<code>Drawable</code>对象</h5><ul><li>一些图片不需要静态的图片资源而是在运行的时候动态的绘制图片，<a href="https://developer.android.google.cn/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="noopener">Drawable</a>对象（<code>shape</code> in XML）在APK中占用很少的资源，并且<a href="https://developer.android.google.cn/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="noopener">Drawable</a>符合<strong>md</strong>的设计原则</li></ul><h5 id="复用资源"><a href="#复用资源" class="headerlink" title="复用资源"></a>复用资源</h5><ul><li><p>比如可以对图像的变化包含一个单独的资源，在图片的旋转，切片等，建议使用同一组资源，然后在使用的时候定制它们。Android提供工具来改变资源的颜色，在5.0以上，可以是使用<code>android:tint</code> 和<code>tintMode</code>，而低版本可以使用<a href="https://developer.android.google.cn/reference/android/graphics/ColorFilter.html" target="_blank" rel="noopener">ColorFilter</a>类来实现。还可以通过旋转图片来达到资源的复用，比如下面的代码就是通过旋转180度，来达到『拇指向上』到『拇指向下』的转变</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml <span class="attribute">version</span>=<span class="string">"1.0"</span> <span class="attribute">encoding</span>=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;rotate xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">  android:<span class="attribute">drawable</span>=<span class="string">"@drawable/ic_thumb_up"</span></span><br><span class="line">  android:<span class="attribute">pivotX</span>=<span class="string">"50%"</span></span><br><span class="line">  android:<span class="attribute">pivotY</span>=<span class="string">"50%"</span></span><br><span class="line">  android:<span class="attribute">fromDegrees</span>=<span class="string">"180"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="代码渲染"><a href="#代码渲染" class="headerlink" title="代码渲染"></a>代码渲染</h5><ul><li>通过代码渲染来试图来节省图片的size，通过代码渲染就可以节省存储图片的空间。</li></ul><h5 id="压缩PNG文件"><a href="#压缩PNG文件" class="headerlink" title="压缩PNG文件"></a>压缩PNG文件</h5><ul><li><p><code>aapt</code>在构建过程中可以优化和无损压缩放置在<code>res/drawable/</code>的图片资源，例如，<code>aapt</code>可以将不需要超过256色的真彩色PNG转换为具有调色板的8位PNG，这样可以相同质量的图片占更小的内存。但是<code>aapt</code>有以下几点局限：</p><ul><li>不能够压缩在<code>asset/</code>文件下的PNG文件</li><li><code>aapt</code>优化图片文件需要256或者更少色</li><li><p><code>aapt</code>可能会填充已经压缩的PNG文件，为了防止个问题，我们应该在<code>Gradle</code>配置中使用<code>cruncherEnabled</code>标志来防止此问题</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">aaptOptions</span> &#123;</span><br><span class="line"><span class="attribute">cruncherEnabled</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="压缩PNG和JPEG文"><a href="#压缩PNG和JPEG文" class="headerlink" title="压缩PNG和JPEG文"></a>压缩PNG和JPEG文</h5><ul><li>可以使用<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="noopener">pngcrush</a>, <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a>, or <a href="https://github.com/google/zopfli" target="_blank" rel="noopener">zopflipng</a>在无损的情况下减少PNG质量，<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="noopener">pngcrush</a>是非常有效的，它遍历PNG过滤器和 zlib (Deflate)参数,使用每个组合的过滤器和参数来压缩图片，然后选择最好的压缩输出，而JPEG可以使用<a href="http://www.elektronik.htw-aalen.de/packjpg/" target="_blank" rel="noopener">packJPG</a>和<a href="https://github.com/google/guetzli" target="_blank" rel="noopener">guetzli</a></li></ul><h5 id="使用WebP文件格式"><a href="#使用WebP文件格式" class="headerlink" title="使用WebP文件格式"></a>使用<code>WebP</code>文件格式</h5><ul><li><p>可以使用<code>WebP</code>格式来代替PNG和JPEG格式，当targeting超过3.2(API 13)，<code>WebP</code>可以提供有损压缩(JPEG)以及透明度(PNG)并且压缩效果要比PNG和JPEG效果好,所以可以使用<code>WebP</code>来代替BMP, JPG, PNG 和静态GIF文件在AS中，更多信息关于<code>WebP</code>可以看 <a href="https://developer.android.google.cn/studio/write/convert-webp.html" target="_blank" rel="noopener">Create WebP Images Using Android Studio</a></p><p><strong>Google Play 只接受启动图标为PNG格式的APK</strong></p></li></ul><h5 id="使用矢量图标"><a href="#使用矢量图标" class="headerlink" title="使用矢量图标"></a>使用矢量图标</h5><ul><li>可以使用矢量图形创建独立于分辨率的图标和其他可伸缩的媒体。使用这些图标可以大大的减少APK的体积，矢量图标在Android中代表<a href="https://developer.android.google.cn/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="noopener">VectorDrawable</a>对象，一个<a href="https://developer.android.google.cn/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="noopener">VectorDrawable</a>对象只需使用100个字节大小就可以生成清晰的图像，但是系统在渲染<a href="https://developer.android.google.cn/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="noopener">VectorDrawable</a>对象时需要大量的时间，所以如果是一张大图，则在显示过程中会花费大量的时间，所以只推荐小图的时候使用矢量图标。更多关于使用<a href="https://developer.android.google.cn/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="noopener">VectorDrawable</a>对象的信息可以看 <a href="https://developer.android.google.cn/training/material/drawables.html" target="_blank" rel="noopener">Working with Drawables</a></li></ul><h5 id="使用矢量动画图像"><a href="#使用矢量动画图像" class="headerlink" title="使用矢量动画图像"></a>使用矢量动画图像</h5><ul><li>千万不要使用<a href="https://developer.android.google.cn/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank" rel="noopener">AnimationDrawable</a>对象来创建帧动画，因为它会需要每一帧的单独的图片文件，所以必定会增加你的APK大小。所以应该使用<a href="https://developer.android.google.cn/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html" target="_blank" rel="noopener">AnimatedVectorDrawableCompat</a>来创建<a href="https://developer.android.google.cn/training/material/animations.html#AnimVector" target="_blank" rel="noopener">animated vector drawables</a></li></ul><h3 id="减少本地和Java代码"><a href="#减少本地和Java代码" class="headerlink" title="减少本地和Java代码"></a>减少本地和Java代码</h3><h5 id="减少不必要的生成代"><a href="#减少不必要的生成代" class="headerlink" title="减少不必要的生成代"></a>减少不必要的生成代</h5><ul><li>要了解自动生成的代码空间大小，例如，许多协议缓冲工具生成了大量的方法和类，可以将应用程序的大小增加一倍甚至更多。</li></ul><h5 id="避免枚举"><a href="#避免枚举" class="headerlink" title="避免枚举"></a>避免枚举</h5><ul><li>一个枚举在应用程序class.dex文件中将会增加1-1.4kb，这些添加会很快的积累到复杂的系统和共享库中，如果可以考虑使用<code> @IntDef</code>注释和<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="noopener">ProGuar</a>处理枚举代码转换为interger值，这样可以保证枚举类型的安全效益。</li></ul><h5 id="减少二进制文件的大小"><a href="#减少二进制文件的大小" class="headerlink" title="减少二进制文件的大小"></a>减少二进制文件的大小</h5><ul><li>如果你的APP中有存在native代码和AndroidNDK代码，也可以通过优化你的代码来减少APP的size，所以可以通过下面2种方式来进行优化。<ul><li>移除debug符号：当你在开发的时候使用debug符号是有意义的，Android NDK 提供<code>arm-eabi-strip</code>工具，用来去除native库中不必要的debug符号，在这之后在打release包。</li><li>避免复制native库：<code>.so</code>文件在APK存储中是不能够被压缩的，在<a href="https://developer.android.google.cn/guide/topics/manifest/application-element.html" target="_blank" rel="noopener"><application> </application></a>元素中设置<code>android:extractNativeLibs</code>标记为false可以避免<a href="https://developer.android.google.cn/reference/android/content/pm/PackageManager.html" target="_blank" rel="noopener">PackManager</a>在应用安装时复制<code>.so</code>文件到文件系统并且还可以使应用程序增量更新更小</li></ul></li></ul><h3 id="维护多个精益的APK"><a href="#维护多个精益的APK" class="headerlink" title="维护多个精益的APK"></a>维护多个精益的APK</h3><ul><li>你的APK可能有用户下载但是却没有使用的内容，像国家和语言信息，使用户能够有一个最小的下载，所以可以将APP分割成几个APK，比如不同的屏幕和GPU支持，当用户下载时，可以根据用户的型号，进行定制下载，下载用户需要的资源，而不需要的不下载，比如<code>hdpi</code>的设备，只需要<code>hdpi</code>资源，而不需要<code>xxxxhdpi</code>资源，所以就是不需要的资源，更多的信息可以查看<a href="https://developer.android.google.cn/studio/build/configure-apk-splits.html" target="_blank" rel="noopener">Configure APK Splits</a>和<a href="https://developer.android.google.cn/training/multiple-apks/index.html" target="_blank" rel="noopener">Maintaining Multiple APKs</a></li></ul><h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><ul><li><a href="https://developer.android.google.cn/topic/performance/reduce-apk-size.html#multiple-apks" target="_blank" rel="noopener">https://developer.android.google.cn/topic/performance/reduce-apk-size.html#multiple-apks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发Android工程中，要尽量减少APK的大小，提高性能&lt;/p&gt;
&lt;h3 id=&quot;理解Apk的结构&quot;&gt;&lt;a href=&quot;#理解Apk的结构&quot; class=&quot;headerlink&quot; title=&quot;理解Apk的结构&quot;&gt;&lt;/a&gt;理解Apk的结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android 4大组件特点</title>
    <link href="https://mrnoknow.github.io/2017/08/02/Android-4%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%89%B9%E7%82%B9/"/>
    <id>https://mrnoknow.github.io/2017/08/02/Android-4大组件特点/</id>
    <published>2017-08-02T04:37:43.000Z</published>
    <updated>2019-03-18T07:53:04.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><ul><li>Acitvity简单的理解为View</li><li>Activity之间使用Intent进行通信</li><li>在AndroidManifest文件进行配置申明</li></ul><h4 id="BoradcastReceiver"><a href="#BoradcastReceiver" class="headerlink" title="BoradcastReceiver"></a>BoradcastReceiver</h4><ul><li>简单的理解为一个监听，对各个广播的监听</li><li>两种注册方式：<ul><li>静态：在AndroidManifest文件中注册，当设备启动并不关闭，这个BoradcastReceiver会一直存在，直到设备关闭。</li><li>动态：在代码中注册，当注册的进程被干掉，这个BoradcastReceiver也被干掉</li></ul></li><li>在onReceive()中不能进行耗时的操作，进行耗时操作时会导致ANR，如果需要耗时操作时，必须启动一个Service服务，不能够使用线程，因为BoradcastReceiver生命周期很短，当线程还没执行完操作，就会被干掉。</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><ul><li>可以在后台进行一些耗时操作的服务</li><li>两种启动方式：<ul><li>startService()，一旦启动，必须在不使用的时候关闭，因为这个时候与启动它的组件无关，它可以在后台无限的运行，必须调用stopSelf()或者stopService()方法关闭它。</li><li>bindService(),调用者与Service进行了绑定，所以会随着调用者的死亡而死亡，不求同年同月生，只求同年同月死的意思</li></ul></li><li>在AndroidManifest文件进行配置申明</li></ul><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><ul><li>内容提供者，内容的共享，通过ContentProvider可以指定Android中可共享的数据，这些数据可以存储在任何合理的方式，其他应用可以通过此组件获取共享数据。</li><li>需要内容共享才需要使用此组件。</li><li>在AndroidManifest文件进行配置申明</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;Activity&quot;&gt;&lt;/a&gt;Activity&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Acitvity简单的理解为View&lt;/li&gt;
&lt;li&gt;Activity之间使用
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>多线程简单介绍</title>
    <link href="https://mrnoknow.github.io/2017/07/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://mrnoknow.github.io/2017/07/28/多线程简单介绍/</id>
    <published>2017-07-28T06:04:38.000Z</published>
    <updated>2019-03-18T07:53:04.663Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Thread-与-Runnable的比较"><a href="#Thread-与-Runnable的比较" class="headerlink" title="Thread 与 Runnable的比较"></a>Thread 与 Runnable的比较</h4><ul><li>Thread需要继承实现，而Java中是单继承，所以我一般不常用Thread，而是使用Runnable接口实现多线程</li></ul><h4 id="关于多线程的几个方法"><a href="#关于多线程的几个方法" class="headerlink" title="关于多线程的几个方法"></a>关于多线程的几个方法</h4><ul><li>sleep()：让当前线程进入休眠状态（<strong>线程不会释放获得的锁</strong>），参数设置休眠时间。</li><li><p>yield()：让步，让不低于自己优先级的线程有机会运行。（<strong>不会释放获取的锁</strong>）</p></li><li><p>interrupt()：终止哪些调用中断方法进入阻塞状态的线程。（<strong>sleep，wait，join都是中断方法</strong>）</p></li><li><p>join()： 当前线程对一个线程调用此方法，当前线程就会停止运行，直到另一个线程执行完成后，才会继续执行当前线程。（<strong>会释放获得的锁，join方法内部调用了wait方法</strong>）</p></li><li><p>wait()：此方法是object的实例方法，让当前线程进入阻塞状态。（<strong>释放获取对象的内部锁</strong>）可通过notify和notifyall来唤醒</p></li><li><p>notify()/notifyall()：是Object的实例方法，notify()是唤醒等待该对象的线程，而notifall()是唤醒所有等待的对象。</p></li></ul><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><ul><li>Java中的每个对象都有一个内部锁，每个类都有一个锁，控制多线程对其静态成员的并发访问。如果一个实例方法使用synchronized关键字修饰，内部锁就会监听这个方法，只有获取到该对象内部锁的线程才能执行此方法。</li><li>对象的内部锁在同一时刻只能由一个线程持有，其他线程尝试获取该对象内部锁都会被阻塞，这种情况下的阻塞不会被中断。</li></ul><h4 id="volatile域"><a href="#volatile域" class="headerlink" title="volatile域"></a>volatile域</h4><ul><li>此关键字可以保证实例域是可见的，通常当我们访问内存中的变量时，就会把它缓存在寄存器中，当需要读这个值时，直接从寄存器拿取，进行加减运算时，直接将寄存器中的值进行加减运行，结束后将值写回内存，问题就出来了，对一个线程对flag变量进行操作，先将flag放进寄存器中，准备将它加上2，这个时候，另一个线程抢占了资源，对flag值进行操作，进行了加3的操作，并将flag写回了内存，这时，第一个线程对flag继续进行操作，对原来的flag值进行操作，加2，然后写回内存，当我们读取时就会发现，flag值为2，所以volatile就是为了解决该问题，就是每次访问变量时，直接从内存拿值，而不会从寄存器中获取。</li></ul><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li>Java核心技术点之多线程 <a href="http://www.cnblogs.com/absfree/p/5327678.html" target="_blank" rel="noopener">http://www.cnblogs.com/absfree/p/5327678.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Thread-与-Runnable的比较&quot;&gt;&lt;a href=&quot;#Thread-与-Runnable的比较&quot; class=&quot;headerlink&quot; title=&quot;Thread 与 Runnable的比较&quot;&gt;&lt;/a&gt;Thread 与 Runnable的比较&lt;/h4&gt;&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView简单复用适配器的实现</title>
    <link href="https://mrnoknow.github.io/2017/07/20/RecyclerView%E7%AE%80%E5%8D%95%E5%A4%8D%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://mrnoknow.github.io/2017/07/20/RecyclerView简单复用适配器的实现/</id>
    <published>2017-07-20T07:17:57.000Z</published>
    <updated>2019-03-18T07:53:04.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个简单RecyclerView复用适配器的实现"><a href="#一个简单RecyclerView复用适配器的实现" class="headerlink" title="一个简单RecyclerView复用适配器的实现"></a>一个简单RecyclerView复用适配器的实现</h3><p><strong>其实现方法与复用的ListView基本相似，但在实例化ViewHolder时，我在RecyclerView里使用的是单例模式，而在ListView直接判View是否为null，设置Tag来实现，但都是只创建一个ViewHolder</strong></p><ul><li><p>RecyclerView代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycleryAdapter</span>&lt;<span class="type">T</span>&gt;  <span class="title">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> int layoutId;</span><br><span class="line">    <span class="keyword">public</span> RecycleryAdapter(Context context,List&lt;T&gt; list,int layoutId)&#123;</span><br><span class="line">        <span class="keyword">this</span>.context=context;</span><br><span class="line">        <span class="keyword">this</span>.list=list;</span><br><span class="line">        <span class="keyword">this</span>.layoutId=layoutId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerViewHolder.<span class="keyword">get</span>(context,viewGroup,layoutId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i) &#123;</span><br><span class="line">        <span class="function"><span class="title">fun</span><span class="params">((RecyclerViewHolder)</span></span> viewHolder,list.<span class="keyword">get</span>(i));</span><br><span class="line">        <span class="function"><span class="title">fun</span><span class="params">((RecyclerViewHolder)</span></span> viewHolder,list.<span class="keyword">get</span>(i),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> void <span class="function"><span class="title">fun</span><span class="params">(RecyclerViewHolder viewHolder, T <span class="keyword">data</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> void <span class="function"><span class="title">fun</span><span class="params">(RecyclerViewHolder viewHolder, T <span class="keyword">data</span>,int i)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> int getItemCount() &#123;</span><br><span class="line">        <span class="keyword">return</span> list==<span class="literal">null</span>?<span class="number">0</span>:list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewHolder代码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt; View&gt; mViews;</span><br><span class="line">    <span class="keyword">private</span> View Fview;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RecyclerViewHolder recyclerViewHolder;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RecyclerViewHolder</span><span class="params">(View parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.mViews=<span class="keyword">new</span> SparseArray&lt;View&gt;();</span><br><span class="line">        Fview= parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RecyclerViewHolder get(Context context, ViewGroup viewGroup,</span><br><span class="line">                                  <span class="keyword">int</span> layoutId)&#123;</span><br><span class="line">        <span class="keyword">if</span>(recyclerViewHolder==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecyclerViewHolder(LayoutInflater.from(context).inflate(layoutId, viewGroup, <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recyclerViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> View&gt; <span class="function">T <span class="title">getView</span><span class="params">(<span class="keyword">int</span> viewId)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        View view = (View) mViews.get(viewId);   <span class="comment">//从 集合中找，没有找到从当前所在布局文件中找</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            view = Fview.findViewById(viewId);</span><br><span class="line">            mViews.put(viewId, view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setTypeface</span><span class="params">(<span class="keyword">int</span> id, Typeface typeface)</span></span>&#123;</span><br><span class="line">        TextView textView=getView(id);</span><br><span class="line">        textView.setTypeface(typeface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">int</span> textId,String textView)</span></span>&#123;</span><br><span class="line">        TextView tv=getView(textId);</span><br><span class="line">        tv.setText(textView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MainActivity代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MainActivity <span class="keyword">extends</span> AppCompatActivity &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; paths;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; items;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Typeface&gt; res;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Log.i(<span class="string">"ssssssssssss"</span>,<span class="string">"1111111111111"</span>);</span><br><span class="line">        inti();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  inti()&#123;</span><br><span class="line">        items=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        paths=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        path=<span class="string">"/system/fonts/"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(path);</span><br><span class="line">        <span class="keyword">File</span>[] files = f.listFiles();<span class="comment">// 列出所有文件</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">count</span> = files.length;<span class="comment">// 文件个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">File</span> <span class="keyword">file</span> = files[i];</span><br><span class="line">                items.add(<span class="keyword">file</span>.getName());</span><br><span class="line">                paths.add(<span class="keyword">file</span>.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="keyword">new</span> ArrayList&lt;Typeface&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;paths.<span class="keyword">size</span>();i++)&#123;</span><br><span class="line">            res.add(Typeface.createFromFile(paths.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        RecyclerView recyclerView=(RecyclerView)findViewById(R.id.recyclerView);</span><br><span class="line">        recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</span><br><span class="line">        recyclerView.setAdapter(<span class="keyword">new</span> RecycleryAdapter&lt;Typeface&gt;(<span class="keyword">this</span>,res,R.layout.item) &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> fun(RecyclerViewHolder viewHolder, Typeface data) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> fun(RecyclerViewHolder viewHolder, Typeface data, <span class="keyword">int</span> i) &#123;</span><br><span class="line">                viewHolder.setTypeface(R.id.textView,data);</span><br><span class="line">                viewHolder.setTypeface(R.id.textView1,data);</span><br><span class="line">                viewHolder.setText(R.id.textView1,items.get(i));</span><br><span class="line">                viewHolder.setText(R.id.textView,<span class="string">"北京上海40$50°ABCabc"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>其实基本上和ListView中的实现是差不多，区别就是ViewHolder的实现，单例模式，需要理解的就是ViewHolder中的代码</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个简单RecyclerView复用适配器的实现&quot;&gt;&lt;a href=&quot;#一个简单RecyclerView复用适配器的实现&quot; class=&quot;headerlink&quot; title=&quot;一个简单RecyclerView复用适配器的实现&quot;&gt;&lt;/a&gt;一个简单RecyclerVi
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>java透过内存看数据类型</title>
    <link href="https://mrnoknow.github.io/2017/07/19/java%E9%80%8F%E8%BF%87%E5%86%85%E5%AD%98%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://mrnoknow.github.io/2017/07/19/java透过内存看数据类型/</id>
    <published>2017-07-19T10:17:10.000Z</published>
    <updated>2019-03-18T07:53:04.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><ul><li><p>基本数据类型</p><ul><li>char</li><li>int</li><li>short</li><li>long</li><li>byte</li><li>float</li><li>double</li><li><p>boolean<br><strong>基本数据开辟空间在正常情况下都是在创建在栈内，并且基本数据类型有有一个特点，比如</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span>=1;</span><br><span class="line"><span class="attribute">int b</span>=1;</span><br></pre></td></tr></table></figure><p><strong>a和b引用的其实是同一块内存，值为1的内存，当在创建一个int c=1，c也会指向同一块内存，当<br>a=2时，将会在java内存重新开辟一块值为2的内存，记住基本类型内存时开辟在Java的栈中的，<br>栈不止有方法的栈入栈出，还会包含基本类型的数值。</strong></p></li></ul></li><li><p>引用数据类型</p><ul><li>class</li><li>interface</li><li>数组<br><strong>引用数据类型和基本数据类型就完全不一样，引用类型会在栈创建一个指针，当数据实例化后就会在堆内存中创建一块内存，供创建的实例使用，栈内指针指向堆内对象，这里有一个注意点，就是Java中有一个Class对象，这个对象和class实例出来的对象不一样，一般Java在调用class对象中的静态方法或者静态值（其实实例化就是调用了静态方法）后，会先创建一个Class对象在运行时常量池中，大家都知道，常量池中存储的都是一些字符信息，这个Class对象就是按照这些来创建的，当你new一个对象后，你调用的方法入口都只有一个就是Class对象的描述的方法地址入口，不会改变，也就是说，你同一class对象类型的方法入口只有一个，java中的反射机制也是通过Class对象来实现的，所以我们总是会说，Java中的”==”,比较的是地址，其实比较的就是一块栈内的指针地址，所以我们就能够理解基本类型的比较为什么比较的值了有看过String源码的人会发现String中的equals其实是把字符一个一个拿出来比的，也就是变成基本类型char，基本类型的数组也是一样。</strong></li></ul><h3 id="Java的关键字"><a href="#Java的关键字" class="headerlink" title="Java的关键字"></a>Java的关键字</h3><ul><li><p>final</p><ul><li><p>这个关键字，就是在开始的时候就把这个字存储在了常量池中，并且不可改变，所以是一个常量，其实在Java中，当方法添加这个关键字后，java就会将这个方法优化，在编译时，将此方法内嵌到调用了此方法中的方法中，比如</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> a)&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(a);</span><br><span class="line">&#125;</span><br><span class="line">f()&#123;</span><br><span class="line">  int a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span>(<span class="title">a</span></span>);</span><br><span class="line">  int b=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f()&#123;</span><br><span class="line">  int <span class="attribute">a</span>=1;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  int <span class="attribute">b</span>=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Java中的一个优化，叫内嵌调用，记住当数据添加了final关键字后就会直接放在常量池，并且初始化。这里还有一点一个class对象中的基本数据都会被初始化，而方法中的不会，方法中的数据会在运行时，在运行时常量池中进行初始化，并且使用。</p></li></ul></li><li>static<ul><li>上面提到Class对象，其实这个值就会被放在此对象中，因为在Java中，无论你实现多少个同一类型对象，都只会对应一个Class对象，Class对象存在于运行常量池中，所以此值也就是在运行常量池中。<br><strong>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，运行时常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</strong></li></ul></li></ul></li></ul><h4 id="如上面有错误，望不吝指出，正在学习ing，害怕理解出错。"><a href="#如上面有错误，望不吝指出，正在学习ing，害怕理解出错。" class="headerlink" title="如上面有错误，望不吝指出，正在学习ing，害怕理解出错。"></a>如上面有错误，望不吝指出，正在学习ing，害怕理解出错。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java数据类型&quot;&gt;&lt;a href=&quot;#Java数据类型&quot; class=&quot;headerlink&quot; title=&quot;Java数据类型&quot;&gt;&lt;/a&gt;Java数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;int
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
      <category term="JVM" scheme="https://mrnoknow.github.io/categories/JAVA/JVM/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Andorid 手势识别(GestureDetector)</title>
    <link href="https://mrnoknow.github.io/2017/03/07/Andorid-%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB-GestureDetector/"/>
    <id>https://mrnoknow.github.io/2017/03/07/Andorid-手势识别-GestureDetector/</id>
    <published>2017-03-07T06:32:20.000Z</published>
    <updated>2019-03-18T07:53:04.659Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 先贴代码 </strong></p><p>###<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lenovo.touchscreen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.GestureDetector;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">new</span> MyGesture());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mGestureDetector.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mGestureDetector.setIsLongpressEnabled(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyGesture</span> <span class="keyword">extends</span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">           Log.d(<span class="string">"onDown"</span>, ev.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onDown"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        滚动</span></span><br><span class="line"><span class="comment">        e1按上屏幕的起始位置，e2为离开屏幕的结束位置</span></span><br><span class="line"><span class="comment">        distanceX是X轴起点与终点的水平距离</span></span><br><span class="line"><span class="comment">        distanceY是Y轴起点与终点的水平距离</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onScroll"</span>, e1.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onScroll"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            <span class="keyword">if</span>(distanceX-distanceY&lt;=<span class="number">10</span>||distanceX-distanceY&gt;=<span class="number">-10</span>) System.exit(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        长按</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onLongPress"</span>, ev.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onLongPress"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        抬起</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onSingleTapUp"</span>, ev.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onSingleTapUp"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        按住，比长按要短</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onShowPress "</span>, ev.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onShowPress"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        抛</span></span><br><span class="line"><span class="comment">        e1按上屏幕的起始位置，e2为当前屏幕的位置</span></span><br><span class="line"><span class="comment">        velocityX每秒X轴上移动的像素</span></span><br><span class="line"><span class="comment">        velocityY每秒Y轴上移动的像素</span></span><br><span class="line"><span class="comment">        这2个数据为速率</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onFling e1 "</span>,e1.toString());</span><br><span class="line">            Log.d(<span class="string">"onFling e2 "</span>,e2.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onFling"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        双击，连续</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onDoubleTap"</span>,e.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onDoubleTap"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">          <span class="comment">//  System.exit(0);</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onDoubleTap</span><span class="params">(e)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        抬起确认，手离开屏幕</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"onSingleTapConfirmed"</span>,e.toString());</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"onSingleTapConfirmed"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onSingleTapConfirmed</span><span class="params">(e)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>此段代码是监控整个屏幕，但是上面的TextView不在此范围，因为TextView覆盖了父View，而监控是的父View，<br>所以点击TextView不会有任何反应<br><img src="/images/Andorid 手势识别GestureDetector/1.png" alt=" "></li><li>当你触摸屏幕后，会将MotionEvent 传入重写的onTouchEvent函数中，然后通过GestureDetector.onTouchEvent()<br>将触摸事件的状态传入GestureDetector的各个重写的状态</li><li>在代码中记得添加mGestureDetector.setIsLongpressEnabled(true)这行代码，否则会有事件无法被捕获</li><li>无论什么事件都会触发Ondown()函数</li><li>各个触摸事件<ul><li>单击 <strong> onDown——&gt;onShowPress——&gt;onSingleTapUp——&gt;onSingleTapConfirmed </strong></li><li>双击 <strong> onDown——&gt;onShowPress——&gt;onSingleTapUp——&gt;OnDoubleTap——&gt;onDown——&gt;onShowPress </strong></li><li>长按 <strong> onDown——&gt;onShowPress——&gt;onLongPress </strong></li><li>抛(onFling) <strong> onDown——&gt;onScroll——&gt;onScroll——&gt; ……… ——&gt;onFling </strong><br><strong> 下一节使用手势打开程序 </strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 先贴代码 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;###&lt;br&gt;&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>第一个NDK程序</title>
    <link href="https://mrnoknow.github.io/2017/03/06/%E7%AC%AC%E4%B8%80%E4%B8%AANDK%E7%A8%8B%E5%BA%8F/"/>
    <id>https://mrnoknow.github.io/2017/03/06/第一个NDK程序/</id>
    <published>2017-03-06T06:20:14.000Z</published>
    <updated>2019-03-18T07:53:04.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>  NDK中文为原生开发工具包，从名字就可以看出‘原生’二字，也就是在Android应用中利用C和C++代码的工具，即将C或C++代码嵌入Android代码中<br>  可以用自己的源代码构建，也可以用现有的预构建库。以下几种值得使用，除此情况都不提倡使用：</p><ul><li>在平台之间移植其应用。</li><li>重复使用现有库，或者提供其自己的库供重复使用。</li><li>在某些情况下提高性能，特别是像游戏这种计算密集型应用。</li></ul><h3 id="开发环境的搭建（此项目在windows下中的Android-Studio完成）"><a href="#开发环境的搭建（此项目在windows下中的Android-Studio完成）" class="headerlink" title="开发环境的搭建（此项目在windows下中的Android Studio完成）"></a>开发环境的搭建（此项目在windows下中的Android Studio完成）</h3><ul><li>下载<a href="https://developer.android.com/ndk/downloads/index.html" target="_blank" rel="noopener">NDK压缩包</a></li><li>解压NDK压缩包，此解压尽量不解压到Android studio和sdk中的目录下，否则在后面的AS中的环境添加会出现问题</li><li>将NDK根目录添加到Path环境中</li><li>在cmd中测试<strong> ndk-build </strong> 出现以下信息表示成功<br><img src="/images/第一个NDK程序/1.png" alt=" "></li><li>进入AS，进入File-&gt;Project Structure-&gt;Android Ndk location，将NDK环境添加<br><img src="/images/第一个NDK程序/2.png" alt=" "><br>到这里环境配置完成<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3></li><li>创建一个android工程</li><li><p>在src目录下创建一个NdkJniUtils.java（名字可以自己命名）代码文件，代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lenovo.ndkone;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lenovo on 3/6/2017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NdkJniUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"FirstJniName"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  native <span class="keyword">String</span> getCLanguageString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译NdkJniUtils.java生成.h文件</p><ul><li>Build—&gt; Make Project，生成.classes文件,下图.class 文件在此位置<br><img src="/images/第一个NDK程序/3.png" alt=" "></li><li>进入Terminal中（在最底部一般会有此选项），进入到上图的/debug 目录下，执行<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni com<span class="selector-class">.example</span><span class="selector-class">.lenovo</span><span class="selector-class">.ndkone</span><span class="selector-class">.NdkJniUtils</span></span><br></pre></td></tr></table></figure></li></ul><p>在debug根目录下会生成一个名字超长的.h文件<br><strong> 若使用网上的另一种 javah -d jni -classpath E:/Android/sdk/platforms/android-22/android.jar;../../build/intermediates/classes/debug example.daosong.com.ndkdemo.NDK 可能会出现找不到.class文件的情况 </strong><br><img src="/images/第一个NDK程序/4.png" alt=" "></p><ul><li><p>在src/main目录下创建一个JNI Folder，将生成的.h文件复制到此文件夹中，然后创建一个.c代码文件，.c代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_example_lenovo_ndkone_NdkJniUtils.h"</span> <span class="comment">//此处为自己的.h文件名</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_lenovo_ndkone_NdkJniUtils_getCLanguageString</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line">     <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"This just a test for Android Studio NDK JNI developer!"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>接着创建一个Android.mk文件，文件内容为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE  := FirstJniName //这个自定义名字与后面说到build.gradle中的ndk定义名对应</span><br><span class="line">LOCAL_SRC_FILES := JniUtils.c //这个为创建的.c代码文件名</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/第一个NDK程序/5.png" alt=" "></p><ul><li><p>在app 中的build.gradle中找到defaultConfig{} ，然后在里面添加</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ndk</span> &#123;</span><br><span class="line">        <span class="attribute">moduleName</span> <span class="string">"FirstJniName"</span> // <span class="string">"FirstJniName"</span>与上面的Android.mk中的LOCAL_MODULE 对应</span><br><span class="line">        abiFilters <span class="string">"armeabi"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"x86"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在gradle.properties 添加<strong> android.useDeprecatedNdk=true </strong>否则会出现文件中有c++文件而无法被编译，建议使用Cmake或者ndk-build<br>的错误信息<br>完成以上就成功，即能够运行<br><img src="/images/第一个NDK程序/6.png" alt=" "></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;  NDK中文为原生开发工具包，从名字就可以看出‘原生’二字，也就是在Android应用中利用C和C++代码的工具，即将C或C++代码嵌入A
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>Android Adapter重复绘制问题</title>
    <link href="https://mrnoknow.github.io/2016/12/07/Android-Adapter%E9%87%8D%E5%A4%8D%E7%BB%98%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://mrnoknow.github.io/2016/12/07/Android-Adapter重复绘制问题/</id>
    <published>2016-12-07T05:23:28.000Z</published>
    <updated>2019-03-18T07:53:04.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>今天在实现复用Adapter的时候，我在使用AddView添加组件的时候，发现当界面上下拉动的时候，添加组件会每次增加一个，并且第一部分区域和最后一部分会重复绘制多次<br>如图：</p><p><img src="/images/Android Adapter重复绘制问题/1.gif" alt=""></p><p>然后这是最尴尬的，我不知道它为什么会重复绘制，如果是刷新的话好理解，那为什么第一个和最后一个一开始就重复绘制了如此多的次数<br><strong>以下部分来自<a href="http://www.cnblogs.com/nailperry/p/4675599.html" target="_blank" rel="noopener">http://www.cnblogs.com/nailperry/p/4675599.html</a></strong></p><h4 id="ListView-OnMeasure方法源码"><a href="#ListView-OnMeasure方法源码" class="headerlink" title="ListView.OnMeasure方法源码"></a>ListView.OnMeasure方法源码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> childWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认为0</span></span><br><span class="line">    <span class="keyword">int</span> childHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    mItemCount = mAdapter == <span class="keyword">null</span> ? <span class="number">0</span> : mAdapter.getCount();</span><br><span class="line">    <span class="comment">// ViewMode 处于UNSPECIFIED 状态，且mAdapter.getCount() &gt; 0时绘制首项来探测大小</span></span><br><span class="line">    <span class="keyword">if</span> (mItemCount &gt; <span class="number">0</span> &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED ||</span><br><span class="line">            heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        <span class="comment">// getView(0)</span></span><br><span class="line">        <span class="keyword">final</span> View child = obtainView(<span class="number">0</span>, mIsScrap);</span><br><span class="line"></span><br><span class="line">        measureScrapChild(child, <span class="number">0</span>, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        childWidth = child.getMeasuredWidth();</span><br><span class="line">        <span class="comment">// 更新为item0的高度</span></span><br><span class="line">        childHeight = child.getMeasuredHeight();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  ViewMode 处于UNSPECIFIED 状态，当mItemCount &gt; 0时，heightSize为getView(0)的高度+ListView距离顶部和底部的距离+2*getVerticalFadingEdgeLength；</span></span><br><span class="line"><span class="comment">     *  当mItemCount==0时，childHeight=0，则heightSize返回的仅仅是ListView距离顶部和底部的距离+2*getVerticalFadingEdgeLength</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">        heightSize = mListPadding.top + mListPadding.bottom + childHeight +</span><br><span class="line">                getVerticalFadingEdgeLength() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ViewMode 处于AT_MOST 状态，绘制多个列表项以确定高度。</span></span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        <span class="comment">// 会调用多个getView，这些view将不会被复用</span></span><br><span class="line">        heightSize = measureHeightOfChildren(widthMeasureSpec, <span class="number">0</span>, NO_POSITION, heightSize, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(widthSize , heightSize);</span><br><span class="line">    mWidthMeasureSpec = widthMeasureSpec;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="measureHeightOfChildren方法的源码"><a href="#measureHeightOfChildren方法的源码" class="headerlink" title="measureHeightOfChildren方法的源码"></a>measureHeightOfChildren方法的源码</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> measureHeightOfChildren(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> startPosition, <span class="keyword">int</span> endPosition,</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxHeight, <span class="keyword">int</span> disallowPartialChildPosition) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ListAdapter adapter = mAdapter;</span><br><span class="line">        <span class="keyword">if</span> (adapter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mListPadding.top + mListPadding.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> returnedHeight = mListPadding.top + mListPadding.bottom;</span><br><span class="line">        ...</span><br><span class="line">        View child;</span><br><span class="line">        <span class="comment">// onMeasure传递过来的endPosition==NO_POSITION，也就是-1，则令endPosition取数据源的adapter.getCount() - 1</span></span><br><span class="line">        endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;</span><br><span class="line">        <span class="keyword">final</span> AbsListView.RecycleBin recycleBin = mRecycler;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> recyle = recycleOnMeasure();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[] isScrap = mIsScrap;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从起始位置0（onMeasure中传入的是0）开始，循环地创建ItemView，并累加ItemView的高度，当高度和超过onMeasure传递过来的maxHeight（其实是测量规格中的size）时，跳出循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = startPosition; i &lt;= endPosition; ++i) &#123;</span><br><span class="line">            child = obtainView(i, isScrap);</span><br><span class="line"></span><br><span class="line">            measureScrapChild(child, i, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算高度的时候还需将ItemView间的分隔距离考虑进来</span></span><br><span class="line">                returnedHeight += dividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recycle the view before we possibly return from the method</span></span><br><span class="line">            <span class="keyword">if</span> (recyle &amp;&amp; recycleBin.shouldRecycleViewType(</span><br><span class="line">                    ((LayoutParams) child.getLayoutParams()).viewType)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *  注意，这里addScrapView方法传入的第二个参数也就是position为-1，</span></span><br><span class="line"><span class="comment">                 *  由于Layout过程中调用getScrapView方法时传入的position&gt;=0，</span></span><br><span class="line"><span class="comment">                 *  故position为-1的ScrapView都不会被回收，读懂这句话需要了解RecycleBin类，这里暂不深究。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                recycleBin.addScrapView(child, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            returnedHeight += child.getMeasuredHeight();</span><br><span class="line">            <span class="comment">// 循环提前终止条件</span></span><br><span class="line">            <span class="keyword">if</span> (returnedHeight &gt;= maxHeight) &#123;</span><br><span class="line">                <span class="comment">// 加上第i个的高度后returnedHeight已经超过了maxHeight，故高度探测应结束，说明最多只能容纳到第i个item</span></span><br><span class="line">                <span class="keyword">return</span> (disallowPartialChildPosition &gt;= <span class="number">0</span>) <span class="comment">// Disallowing is enabled (&gt; -1)</span></span><br><span class="line">                            &amp;&amp; (i &gt; disallowPartialChildPosition) <span class="comment">// We've past the min pos</span></span><br><span class="line">                            &amp;&amp; (prevHeightWithoutPartialChild &gt; <span class="number">0</span>) <span class="comment">// We have a prev height</span></span><br><span class="line">                            &amp;&amp; (returnedHeight != maxHeight) <span class="comment">// 第i个Item不能显示完全，即超出容器</span></span><br><span class="line">                        ? prevHeightWithoutPartialChild</span><br><span class="line">                        : maxHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((disallowPartialChildPosition &gt;= <span class="number">0</span>) &amp;&amp; (i &gt;= disallowPartialChildPosition)) &#123;</span><br><span class="line">                prevHeightWithoutPartialChild = returnedHeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnedHeight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>A parent view may call measure() more than once on its children. For example, the parent may measure each child once with unspecified dimensions to find out how big they want to be, then call measure() on them again with actual numbers if the sum of all the children’s unconstrained sizes is too big or too small.</li><li><p>一个父视图可能多次调用子视图的measure方法，意思就是说，当ListView的OnMeasure方法计算完Item的大小，ListView的父视图将要查看此结果，然后进行判定这个结果是否能被接受，若不能，则会再次调用measureHeightOfChildren方法，从而导致getView方法的重复调用，而造成第一行和最后一行被多次绘制<br><strong>但是，那个上下拉后，隐藏的Item重现是再次被绘制还不是不是太清楚，有几张图，然后看了网上的ListView源码解释，还是很模糊，在此先贴图</strong><br><img src="/images/Android Adapter重复绘制问题/2.png" alt=""></p></li><li><p>上图意思很容易看懂，但是我还是无法理解重复绘制的问题，我在代码中添加的组件怎么会在重回屏幕时增加<br><img src="/images/Android Adapter重复绘制问题/3.jpg" alt=""></p></li><li>上图的意思就是，每次内存中只保存显示的几个Item，之后拖动后，被隐藏的Item（View）会保存到Recycler中，当再次回到原来位置时，会从Recycler中获取，感觉好像解释不了重新被绘制的问题<br><strong>总结上面2张图，就是如果你ListView中一个屏幕中有N个Item（View），你的内存中也只会产生N+1个Item（View），无论你ListView中有多少行数据，然后每当一个Item（View）移除屏幕，放在RecycleBin中的Item（View）就会去填充，然后移除的Item（View）进入RecycleBin中，如此循环往复，这里应该表达清楚的是每个Item中的信息是改变的，只是用的View那个对象，和View中的信息无关，所以尽管如此还是不能解释我代码中添加的元素越来越多问题</strong><br><strong>以上基本类似的意思，但是在以上讲解中，并没有提到getView被复用的点，相反而是为了解决此问题和OOM问题所做的解释</strong></li></ul><h3 id="2017-7-26更"><a href="#2017-7-26更" class="headerlink" title="2017-7-26更"></a>2017-7-26更</h3><p>  <strong>对于上面的问题，我在前几天突然豁然开朗，就是ListView中的item放进RecycleBin后，在下拉后会复用RecycleBin中的item，所以在item加一个view后，在复用中，此view还是会存在于此item中，我们每次下拉或者刷新，都只是更改item中的信息，或者图片，并没有添加过view或者其他一些组件，所以当你有item的添加组件操作，会在下面的刷新中，复用此item中的view越来越多，因为我们是在getView（）方法中进行信息或者图片加载，而每次下拉总是会调用getView(),所以添加向item添加view这一操作，证实了itme复用的实现。</strong></p><h3 id="2017-8-1更"><a href="#2017-8-1更" class="headerlink" title="2017-8-1更"></a>2017-8-1更</h3><ul><li>当加载第一页ListView时，会加载比第一页item多2个的item</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;今天在实现复用Adapter的时候，我在使用AddView添加组件的时候，发现当界面上下拉动的时候，添加组件会每次增加一个，并且第一部分区域
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="other" scheme="https://mrnoknow.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>模板Adapter</title>
    <link href="https://mrnoknow.github.io/2016/12/05/%E6%A8%A1%E6%9D%BFAdapter/"/>
    <id>https://mrnoknow.github.io/2016/12/05/模板Adapter/</id>
    <published>2016-12-05T09:38:05.000Z</published>
    <updated>2019-03-18T07:53:04.665Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>当前一个项目会有很多的Adapter与它所对应的Model，所以这样会产生很多的Adapter类与Model，这样代码量就会很大，并且还代码重复多，这是一个烦人的过程，所以需要一个万能的模板Adapter，一个Adapter，所有的ListView都能用</p><h4 id="ViewHolder模板"><a href="#ViewHolder模板" class="headerlink" title="ViewHolder模板"></a>ViewHolder模板</h4><p><em>对此我直接上源码</em><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.againadapter;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.SparseArray;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonViewHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SparseArray&lt; View&gt; mViews;</span><br><span class="line">  <span class="keyword">private</span> View Fview;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 构造函数，设置Tag，</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> CommonViewHolder(Context context, ViewGroup parent, <span class="keyword">int</span> layoutId,  </span><br><span class="line">            <span class="keyword">int</span> position)&#123;</span><br><span class="line">    <span class="keyword">this</span>.mViews=<span class="keyword">new</span> SparseArray&lt;View&gt;();</span><br><span class="line">    Fview=LayoutInflater.from(context).inflate(layoutId, parent,<span class="keyword">false</span>);</span><br><span class="line">    Fview.setTag(<span class="keyword">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 得到Tag</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CommonViewHolder get(Context context, View convertView,  </span><br><span class="line">            ViewGroup parent, <span class="keyword">int</span> layoutId, <span class="keyword">int</span> position)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(convertView==<span class="keyword">null</span>)&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CommonViewHolder(context,parent,layoutId,position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (CommonViewHolder)convertView.getTag();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 最重要获取布局文件中的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> View&gt; <span class="function">T <span class="title">getView</span><span class="params">(<span class="keyword">int</span> viewId)</span>  </span>&#123;  </span><br><span class="line">      </span><br><span class="line">          View view = (View) mViews.get(viewId);   <span class="comment">//从 集合中找，没有找到从当前所在布局文件中找</span></span><br><span class="line">          <span class="keyword">if</span> (view == <span class="keyword">null</span>)  </span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">              view = Fview.findViewById(viewId);  </span><br><span class="line">              mViews.put(viewId, view);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span> (T) view;  </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="function">View <span class="title">getView</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Fview;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 以下全是设置元素信息的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">int</span> textId,String textView)</span></span>&#123;</span><br><span class="line">     TextView tv=getView(textId);</span><br><span class="line">     tv.setText(textView);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setImageResource</span><span class="params">(<span class="keyword">int</span> imageViewId,<span class="keyword">int</span> imageView)</span></span>&#123;</span><br><span class="line">     ImageView im=getView(imageViewId);</span><br><span class="line">     im.setImageResource(imageView);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(<span class="keyword">int</span> imageViewId,Drawable drawable)</span></span>&#123;</span><br><span class="line">     ImageView im=getView(imageViewId);</span><br><span class="line">     im.setImageDrawable(drawable);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setImageBitmap</span><span class="params">(<span class="keyword">int</span> imageViewId,Bitmap bitmap)</span></span>&#123;</span><br><span class="line">     ImageView im=getView(imageViewId);</span><br><span class="line">     im.setImageBitmap(bitmap);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码是不是简短，但是很精辟</p><ul><li>此代码主要在于构造函数，和getView（int viewId）函数，你可以加上Log查看它 的执行过程<h4 id="Adapter模板"><a href="#Adapter模板" class="headerlink" title="Adapter模板"></a>Adapter模板</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.againadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.BaseAdapter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyAdapter</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">BaseAdapter</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">  <span class="keyword">private</span> Context context;</span><br><span class="line">  <span class="keyword">private</span> int layoutId;</span><br><span class="line">  <span class="keyword">public</span> ReplyAdapter(Context context,List&lt;T&gt; list,int layoutId)&#123;</span><br><span class="line">    <span class="keyword">this</span>.context=context;</span><br><span class="line">    <span class="keyword">this</span>.list=list;</span><br><span class="line">    <span class="keyword">this</span>.layoutId=layoutId;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> int getCount() &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object getItem(int poistion) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> poistion;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> long getItemId(int poistion) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> poistion;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> View getView(int poistion, View view, ViewGroup viewGroup) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="comment">/*ViewHolder viewHolder=null;</span></span><br><span class="line"><span class="comment">    view = LayoutInflater.from(context).inflate(</span></span><br><span class="line"><span class="comment">                R.layout.replay_text, null);</span></span><br><span class="line"><span class="comment">    viewHolder=new ViewHolder();</span></span><br><span class="line"><span class="comment">    viewHolder.setText((TextView)view.findViewById(R.id.textView1));</span></span><br><span class="line"><span class="comment">    view.setTag(viewHolder);</span></span><br><span class="line"><span class="comment">    viewHolder.getText().setText(list.get(poistion));*/</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*  CommonViewHolder viewHolder=CommonViewHolder.get(context, view, viewGroup, R.layout.replay_text, poistion);</span></span><br><span class="line"><span class="comment">    TextView tv=viewHolder.getView(R.id.textView1);</span></span><br><span class="line"><span class="comment">    tv.setText(list.get(poistion)); </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CommonViewHolder viewHolder=CommonViewHolder.<span class="keyword">get</span>(context, view, viewGroup, layoutId, poistion);</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">(viewHolder,list.<span class="keyword">get</span>(poistion)</span></span>);</span><br><span class="line">    <span class="keyword">return</span> viewHolder.getView();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> void <span class="function"><span class="title">fun</span><span class="params">(CommonViewHolder viewHolder,T <span class="keyword">fun</span>)</span></span>;<span class="comment">//直接重写此函数，设置你需要设置的元素信息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.againadapter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.AdapterView;</span><br><span class="line"><span class="keyword">import</span> android.widget.ListView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="title">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; mDatas=new ArrayList&lt;Integer&gt;(Arrays.asList(R.drawable.ic_launcher,R.drawable.<span class="keyword">fun</span>));</span><br><span class="line">  <span class="keyword">private</span> ListView listView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        listView=(ListView)findViewById(R.id.listView1);</span><br><span class="line">        listView.setOnItemClickListener(new AdapterView.OnItemClickListener()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,</span><br><span class="line">          long arg3) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Log.i(<span class="string">"ssssssssss"</span>, <span class="string">"fun"</span>);</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  直接设置Adapter,重写fun函数，设置元素信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        listView.setAdapter(new ReplyAdapter&lt;Integer&gt;(<span class="keyword">this</span>,mDatas,R.layout.replay_text)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      void <span class="function"><span class="title">fun</span><span class="params">(CommonViewHolder viewHolder, Integer <span class="keyword">fun</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        viewHolder.setText(R.id.textView1, <span class="string">"ssssss"</span>);</span><br><span class="line">        viewHolder.setImageResource(R.id.imageView1, <span class="function"><span class="keyword">fun</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上是看完张鸿洋博客，依葫芦画瓢写的一个例子，博文地址<a href="http://blog.csdn.net/lmj623565791/article/details/38902805/" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/38902805/</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;当前一个项目会有很多的Adapter与它所对应的Model，所以这样会产生很多的Adapter类与Model，这样代码量就会很大，并且还代码
      
    
    </summary>
    
      <category term="Android" scheme="https://mrnoknow.github.io/categories/Android/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <link href="https://mrnoknow.github.io/2016/12/04/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://mrnoknow.github.io/2016/12/04/垃圾收集器与内存分配策略/</id>
    <published>2016-12-04T06:02:04.000Z</published>
    <updated>2019-03-18T07:53:04.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="垃圾收集器概述"><a href="#垃圾收集器概述" class="headerlink" title="垃圾收集器概述"></a>垃圾收集器概述</h3><ul><li>垃圾收集（Garbage Collection，GC）在1960年诞生于MIT的Lisp第一门真正使用内存动态分配和垃圾收集技术的语言</li><li>程序计数器，虚拟机栈，本地方法栈都是随线程而生，随线程而灭，所以没有垃圾回收</li><li>java堆和方法区实现GC，一个接口中的多个实现类需要的内存都不一样，一个方法中的多个分支需要的内存也可能不一样，程序在运行中才会知道创建哪些对象，所以创建和回收都是动态的，GC所关注的是这部分内存<h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><strong>在GC回收前要判断哪些对象是”存活”，哪些“死去”，可以回收</strong></li><li><strong>引用计数法（Reference Counting）</strong><ul><li>给对象添加一个引用计数器，没有一个地方引用它，计数器加1，当引用失效，计数器减1，任何时刻计数器值为0时对象就是不可能在被使用了</li><li>此法实现简单，效率高，微软的COM（Component Object Model）技术，使用ActionScript3的FlashPlayer，Python语言和在游戏脚本领域被广泛应用的Squirrel</li><li>难以解决对象之间相互循环引用的问题</li></ul></li><li><strong>可达性分析算法（Reachability Analysis）</strong><br><em>主流程序语言（Java，C#，古老的Lisp）都使用它</em><ul><li>通过一系列“GC Roots”的对象作为起始点，从这些节点开始往下搜索，所经过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的（即被回收）</li><li>可做GC Roots：虚拟机栈（帧栈中的本地变量表）中的引用对象，方法区中的类静态属性引用的对象，方法区中的常用引用的对象，本地方法中的JNI（即Native方法）引用的对象<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3></li></ul></li><li>很多人认为方法区是没有垃圾收集的，java虚拟机规范中说过不要求虚拟机中在方法区实现垃圾收集</li><li>方法区中垃圾收集的效率非常低，在堆中，特别是新生代，常规的一次垃圾收集可回收70%~95%的空间，而方法区远低于此</li><li>方法区垃圾收集主要是2部分内容：<strong>废弃常量和无用的类</strong><ul><li>废弃常量和java堆中的对象非常相似，如果一个字段没有任何对象引用，则将回收</li><li>无用的类的判定（以下仅仅是“可以”，不像java对中的对象实例一样，一定被回收）<ul><li>该类所有的实例都被回收，也就是java堆中不存在改类的任何的实例</li><li>加载改类的ClassLoader已经被回收</li><li>该类对于的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li><li>在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP 以及OSGi这类频繁自定义ClassLoader的场景需要虚拟机具备类卸载的功能，以保证方法区不溢出<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></li></ul></li><li><strong>标记——清除算法（Mark-Sweep，最基本的回收算法）</strong><ul><li>标记所有需要回收的对象，然后统一回收所有被标记的对象</li><li>缺点：1.效率不高，2,.容易产生大量的不连续的内存碎片，在分配大大对象的时候，无法找到足够的连续内存，会触发垃圾收集回收</li></ul></li><li><strong>标记——整理算法</strong><ul><li>对标记——清除算法的改进，在标记后，让所有存活的对象向一端移动，然后直接清理掉标记内容，以保证不产生不连续的内存碎片</li></ul></li><li><strong>复制算法</strong><ul><li>将可用内存划分为大小相等的两块，每次使用其中的一块，当一块内存用完，就将存活对象复制到另外一块上面，然后将使用过的那块一次清除掉</li><li>缺点：内存缩小，花费太大</li><li>IBM研究表明新生代对象98%是可被回收的，所以不用采用1:1的比例分配内存，将内存分配为<strong>一块较大的Eden</strong>和<strong>两块较小的Survivor</strong>，每次使用一块Eden和Survivor，回收时将Eden和Survivor存活的对象复制到另一块Survivor内存上，HotSpot虚拟机默认Eden：Survivor=8:1</li></ul></li><li><strong>分代收集算法（Mark-Compact，目前最主流）</strong><ul><li>根据对象存活的不同周期，将内存划分为几块，根据各个特点选择最合理的收集回收算法<h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3></li></ul></li><li><strong>枚举根节点</strong>（可达性分析中GC Roots节点引用链这个操作为例）<ul><li>可作为GC Roots的节点在全局性的引用（比如常量或类静态属性）与执行上下文（例如帧栈中的本地变量表），很多应用在方法区有100+M以上，如果每个引用都检查，会消耗大量时间</li><li>可达性分析对执行时间的敏感体现在GC停顿，分析工作必须保持在一致性的快照中，即在分析期间系统冻结在某一时刻，导致GC执行时必须停到所有的java线程（“Stop The World”） ，</li><li>目前主流java虚拟机使用准确式GC，当执行系统停下来后，不需要检查全部的执行上下文和全局引用位置，虚拟机有办法知道哪些地方存放了对象</li><li>在HotSpot中，使用一组叫<strong>OopMap</strong>的数据结构在类加载的时候，就把对象内什么偏移量是什么类型的数据计算出来，在JIT编译过程，也会在特定的位置下记录下栈和寄存器中哪些位置是引用，在GC扫描时，就可以直接得到哪些地方存放了对象了</li></ul></li><li><strong>安全点（SafePoint）</strong><br><em>通过OopMap可以快速且准确的完成GC Roots枚举，但可能导致引用关系变化，或者OopMap内容变化的指令非常多，若每条指令都有一个OopMap，那将需要大量的额外空间</em></li><li>HotSpot不会为每一条指令生成OopMap，它只会在安全点来记录这些信息</li><li>SafePoint 的选定不能太少也不能太频繁导致运行时的负荷增大，它的选定是以程序“是否具有长时间的执行的特征”的标准而选定的，长时间最明显的特征就是指令序列复用（方法调用，循环跳转，异常跳转），从而产生SafePoint</li><li>GC Roots如何让所有线程停下来（不包括JNI调用的线程），然后执行到安全点，有2种方法<ul><li><strong>抢断式中断（Preemptive Suspension）</strong>，在GC 发生时，把所有线程中断，然后把没有达到安全点的线程恢复运行直到到达安全点（此方法以不在使用）</li><li><strong>主动式中断（Voluntary Suspension）</strong>，在GC 需要中断线程时，不直接对线程进程操作，仅仅设置一个简单的标志（安全点位置），各个线程执行时主动轮询此标志，发现中断标志时，自己中断挂起</li></ul></li><li><strong>安全区域（Safe Region）</strong><ul><li>当线程进入Sleep状态或者Blocked状态，线程无法响应JVM中断请求，JVM不会等到线程被分配Cpu时间然后运行到安全点，所以我们把这样一种状态就表示为线程进入安全区域</li><li>当线程进入安全区域会把自己标示为进入Safe Region，当GC行为发生时，就不用管进入安全区域的线程，当线程要脱离Safe Region状态时，就需要检查GC是否完成，若没完成，要等待他完成后，才可以继续<h3 id="垃圾收集器（JDK-1-7-Update-14之后的HotSpot虚拟机）"><a href="#垃圾收集器（JDK-1-7-Update-14之后的HotSpot虚拟机）" class="headerlink" title="垃圾收集器（JDK 1.7 Update 14之后的HotSpot虚拟机）"></a>垃圾收集器（JDK 1.7 Update 14之后的HotSpot虚拟机）</h3><em>垃圾收集器是内存回收的具体实现，java虚拟机对垃圾收集器没有任何规定，因此不同厂商，不同版本的垃圾收集有很大的差别</em></li></ul></li><li><strong>Serial收集器</strong><ul><li>最基本，最古老的收集器</li><li>单线程收集器，并不仅仅是只使用一个Cpu或一个线程去收集，而它收集的时候回暂停所有的工作线程，知道它收集结束</li><li>它仍然是虚拟机运行在Client下的默认新生代收集器，因为它简单而高效（与其他单线程相比），在单线程下，Serial没有线程交互的开销，在用户桌面级下，一般虚拟机管理的内存不会太大，所以它的效率依然 高效</li></ul></li><li><strong>ParNew 收集器</strong><ul><li>ParNew为Serial收集器的多线程版本，除此之外没有太多创新之处</li><li>是运行在Server模式下的虚拟机首选新生代收集器</li><li>除了Serial收集器外，唯一能与CMS收集器配合工作的收集器</li><li>单个CPU，ParNew没有Serial效果好，2个CPU也无法保证100%比Serial效果好，以为存在在线程的交互</li></ul></li><li><strong>Parallel Scavenge收集器（“吞吐量优先”收集法）</strong><br>*与ParNew一样是多线程新生代收集器，使用复制算法，但是它更关注一个可控制的吞吐量，即CPU运行用户代码时间与ＣＰＵ总消耗时间的比值（吞吐量＝运行用户代码时间／（运行用户代码时间＋垃圾收集时间）），运行１００分钟，垃圾收集１分钟，吞吐量＝９９%<ul><li>此方法会根据运行情况收集性能监控信息，然后动态调整参数以提供最合适的停顿时间或者最大吞吐量，这种调节叫做GC自适应调节策略（GC Ergonomics）</li></ul></li><li><strong>Serial Old收集器</strong><ul><li>是Serial收集器的老年代版本，单线程收集器，“标记——整理算法”</li><li>用于Client模式下的虚拟机使用</li><li>在Server模式下，2大功能：1.在JDK1.5之前是与Parallel Scavenge配合使用，2.做为CMS收集的后备预案</li></ul></li><li><strong>Parallel Old收集器</strong><ul><li>是Parallel Scavenge收集器的老版本，使用多线程和“标记——整理算法”</li><li>若在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old组合</li></ul></li><li><p><strong>CMS （Concurrent Mark Sweep）收集器（并发低停顿收集器）</strong></p><ul><li>是一种以获取最短回收停顿时间的收集器，用“标记——清除算法”，收集步骤<ul><li><strong>初始标记（CMS initial mark）</strong>，需要“Stop The World”，标记GC Roots能直接关联的UI小，速度很快</li><li><strong>并发标记（CMS concurrent mark）</strong>，需要“Stop The World”，进行GC Roots Tracing的过程</li><li><strong>重新标记（CMS remark）</strong>，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，比初始标记时间长，远比并发标记时间段</li><li><strong>并发清除（CMS concurrent sweep）</strong>，并发消除标记的对象</li><li>因为用时最长的并发标记和并发消除都可以与用户线程一起工作，所以停顿低</li></ul></li><li>CMS收集器对CPU资源很敏感（面向并发设计的程序对CPU资源都非常敏感），在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源而导致应用程序变慢，所以当CPU数量太少，就会导致用户程序执行速度直线下降，为了解决此问题，虚拟机提供“增量式并发收集器”（Increment Concurrent Mark Sweep/i-CMS），所用单CPU时的抢占式来模拟多任务机制思想，交替GC线程与用户线程，但是方法效果一般，所以已经不提倡用户使用</li><li>CMS收集器无法处理<strong>浮动垃圾（Floating Garbage）</strong>，可能出现“Concurrent Mode Failure”，失败后会导致Full GC（老年代回收）产生，因为CMS并发清理时用户线程还在进行，所以会不断的产生新的垃圾，这一部分垃圾无法在此次清理，只有下一次才能处理他们，所以需要预留内存空间给用户线程使用，所以需要设置一个百分比来触发Full GC，在jdk1.5为老年代使用的68%，在jdk1.6，已经上升为92%，如果在不满足此条件时，出现“Concurrent Mode Failure ”会启动预备方案：临时启用Serial Old收集器对老年代垃圾进行收集</li><li>CMS是“标记——清除算法”，所以会有大量的空间碎片产生，这样就会导致老年代有很大空间，但是没有一块连续足够大的空间来分配当前对象，而触发Full GC，所以当CMS 有一参数（UsCMSCompactAtFullCollection）来停顿在要Full GC时开启碎片合并整理</li></ul></li><li><p>G1收集器</p><ul><li>从JDK 6u14中就开始就提供给开发人员实验，试用，到JDK7u4，才正式使用</li><li>G1收集器是面向服务端的垃圾收集器，主要目的是在未来可以替换CMS收集器</li><li>与其他GC收集相比，有以下不同：<ul><li><strong>并行与并发</strong>：G1收集器能够利用多CPU，多核环境下的硬件优势，使用多个CPU来缩短Stop The World停顿的时间，部分收集器需要停顿java线程来进行GC动作，但G1可以通过并发让java线程继续执行</li><li><strong>分代收集</strong>：G1可以独立的管理整个GC堆，它可以采用不同的方式去处理新创建的对象和已经存活了一段时间的对象</li><li><strong>空间整合</strong>：G1从整体是基于“标记——整理算法”的收集器，从局部（2个Region之间）是基于“复制算法”，但是这2种算法都不会产生空间碎片，所以不会因为创建大对象而找不到空间触发GC</li><li><strong>可停顿的预测</strong>：这是G1相对于CMS的一大优势，降低停顿时间是G1和CMS共同目标，但G1还能够建立可预测的停顿时间模型，能让使用者指定一个长度为M毫秒的时间内，垃圾收集上不得超过N毫秒，这几乎是实时Java（RTSJ）的垃圾收集器特征了</li></ul></li></ul></li><li>java堆的内存布局与其他收集器有很大的差别，它将整个java堆划分为多个大小相等的独立区域（Region），保留着新生代和老年代的概念，新生代和老年代不再是物理隔离，他们都是一部分Region（不需要连续）的集合</li><li>G1收集器建立可预测的停顿时间模型，是因为他能够避免在java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收获得的空间大小以及回收需要的时间），，在后台维护一个优先列表，每次根据回收价值最大的Region（Garbage—First的由来），这可以保证在G1在有线的时间内可以获取尽可能高的收集效率</li><li>java堆虽然被划分为相等的独立区域（Region），但是Region中的对象可能被其他Region中的对象引用，所以可能被整个java堆任意对象发生引用关系，所以确保对象是否存活岂不是要扫描整个java堆，在虚拟机中使用<strong>Remembered Set</strong>来避免扫描，G1中每个Region都有一个Remembered Set，虚拟机在Reference类型数据进行写操作时会有一个Write Barrier暂时中断写操作，检测tReference引用的对象是不是在不同Region之间，如果是，便通过CardTable把相关引用信息记录到被引用对象的Region的Remembered Set之中，在GC根节点的枚举范围中加入Remembered Set即可以保证不对全堆扫描也不会有遗漏。</li><li>忽略维护Remembered Set 的操作，G1收集器运行时以下步骤：<ul><li><strong>初始标记（Initial Marking）</strong>，标记GC Roots能直接关联的对象，并修改TAMS（Next Top at  Mark Start）的值，让用户程序并发运行时，能够在正确可用的Region中创建新对象，需要停顿线程，但时间很短</li><li><strong>并发标记（Concurrent Marking）</strong>，进行可达性分析，找出存活的对象，时间很长，但可以与用户程序并发执行</li><li><strong>最终标记（Final Marking）</strong>，修正在并发标记期间因用户程序继续运行而导致标记产生变化的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，然后最终标记把Logs中的数据整合到Remembered Set中，需要停顿线程，但是可以并执行</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong>，筛选回收价值和成本Region进行排序，根据用户所期望的GC停顿时间制定回收计划，这部分可以与用户程序并发执行<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><strong>对象的内存分配，往大方向讲，就是在堆上分配（也可能进过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代Eden 上，如果启动本地线程分配，则按线程优先在TLAB上分配，也有情况在老年代分配，分配规则很多。</strong><br>下面是几种最普遍的分配方式：</li></ul></li><li><strong>对象优先在Eden上分配</strong></li><li><strong>大对象直接进入老年代</strong></li><li><strong>长期存活对象进入老年代</strong></li><li><strong>动态对象年龄判断</strong></li><li><strong>空间分配担保</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;垃圾收集器概述&quot;&gt;&lt;a href=&quot;#垃圾收集器概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器概述&quot;&gt;&lt;/a&gt;垃圾收集器概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;垃圾收集（Garbage Collection，GC）在1960年诞生于MIT的Lisp
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
      <category term="JVM" scheme="https://mrnoknow.github.io/categories/JAVA/JVM/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java内存区域与内存溢出异常</title>
    <link href="https://mrnoknow.github.io/2016/12/02/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>https://mrnoknow.github.io/2016/12/02/java内存区域与内存溢出异常/</id>
    <published>2016-12-02T11:27:31.000Z</published>
    <updated>2019-03-18T07:53:04.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img src="/images/java内存区域与内存溢出异常/2.png" alt=" "></p><ul><li><strong>程序计数器（Program Counter Register）</strong><ul><li>是一块很小的内存空间</li><li>是当前线程所执行的字节码指示器，字节码解释器执行是通过改变它的值来选取下一跳执行命令</li><li>单核处理器在确定时刻只能执行一条线程中的指令，为了让线程切换后能恢复到正确的位置，每个线程都有一个独立的程序计数器，这类内存区域称为“线程私有‘’</li><li>线程执行java方法，计数器记录正在执行的虚拟机字节码指令地址，若执行native方法，计数器值为空。</li><li>程序计数器是唯一规定没有OutofMenoryError情况的内存</li></ul></li><li><strong>虚拟机栈（VM Stack）</strong><ul><li>描述java方法执行内存模型（字节码）</li><li>虚拟机栈是线程私有</li><li>每个方法执行都会创建一个帧栈，帧栈保存局部变量，操作数栈等信息，每个方法的执行都是帧栈在虚拟机栈中的入栈与出栈的过程<ul><li>局部变量表存储的是基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型（指向一条字节码指令的地址）</li><li>long 和double 占用了2个局部变量，其他的数据类型占用1个</li><li>局部变量表所需的内存空间在编译期间完成分配，在运行期间是不会被改变的</li></ul></li><li>当java虚拟机进行动态扩展时，无法申请足够的内存将抛出OutOfMemoryError异常</li><li>线程请求的栈深度大于虚拟机允许的深度将抛出StackOverflowError异常</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong><br> <strong>与虚拟机栈相似</strong><ul><li>描述native方法执行的内存模型。</li><li>对使用的语言，使用方式与数据结构没有强制要求，虚拟机可自由使用它。</li><li>有的将本地方法栈与虚拟机栈合二为一（Sun HotSpot虚拟机）</li><li>抛出OutOfMenmoryError与StackOverflowError异常</li></ul></li><li><strong>Java堆（Java Heap）</strong><ul><li>是虚拟机管理的内存最大的一块</li><li>唯一目的是存放对象实例</li><li>几乎所有的对象实例都在堆上分配内存（随着JIT编译器的发展与逃逸分析技术的成熟，栈上分配与标量替换优化技术导致堆上分配不是那么绝对）</li><li>垃圾收集器（GC）管理的主要区域，因此很多时候被称作“”GC堆“”</li><li>可以处于物理上不连续的内存空间，但逻辑要连续</li><li>在实现上，可实现固定大小，也可扩展（当前主流都可扩展）</li><li>当堆中没有内存完成实例分配，且堆无法再扩展时，抛出OutOfMenmoryError异常</li></ul></li><li><strong>方法区（Method Area）</strong><ul><li>存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</li><li>在实现上，可实现固定大小，也可扩展（当前主流都可扩展）</li><li>垃圾收集行为在这个区域比较少出现，回收目标主要是：常量池的回收和对类型的卸载（类型的卸载回收条件苛刻），这部分回收是非常必要的，否则会导致内存泄露</li><li>当方法区无法满足内存分配需求时，抛出OutOfMenmoryError异常</li><li><strong>运行时常量池（Runtime Constant Pool）</strong><br><em>class文件除了有类型的版本，字段，方法，接口等描述信息外，还有常量池（Constant Pool Table）用于存放编译期生成的各种字面量和符号引用，这些内容在类加载后进入方法区的运行时常量池中保存</em><ul><li>java虚拟机对Class文件每个文件（包括常量池）格式都有严格的规定，但是对运行时常量池没有做任何细节要求（不同的提供商实现的虚拟机可根据自己的要求来实现这部分）</li><li>翻译出来的直接引用也存储在运行时常量池中</li><li>java语言不要求常量一定在编译期时产生，也就是并非与预置入 Class文件中常量池内容才能进入运行时常量池，运行期间也能将新的常量放入池中（String类的intern（）方法）</li><li>无法申请到内存时抛出OutOfMenmoryError异常</li></ul></li></ul></li><li><strong>直接内存（Direct Memory）</strong><ul><li>并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但这部分内存被频繁使用</li><li>在jdk1.4中新加入NIO（New Input/Output）类，引入基于通道（Channel）与缓冲区（Buffer）的I/O方式，它用Native函数库直接分配堆外内存，然后通过java堆中的DirectByteBuffer对象作为这块内存的引用操作，避免java堆和Native堆中来回复制数据</li><li>直接内存不受java虚拟机的限制，受本机内存大小以及处理器寻址空间的限制，当内存区域大于物理内存限制，抛出OutOfMenmoryError异常<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3></li></ul></li><li><strong>对象创建</strong><ul><li>虚拟机遇到new指令时，首先去检测这个指令参数是否能在常量池中定位到一个类的符号引用，检测这个符号引用代表的类是否已被加载，解析和初始化过，若没有则进行类加载过程</li><li>类加载完成后（所需内存确定），虚拟机为对象分配内存（从java堆中分配一块内存）</li><li>2种分配方式：<ul><li><strong>指针碰撞（Bump the Pointer）</strong>,若java堆中的内存时绝对规整的，所有用过的在一边，没有用过的在一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把那个指针向空闲的空间那边挪到一段与对象大小相等的距离</li><li><strong>空闲列表（Free List）</strong>，如java堆内存不是规整的，使用和未使用的内存相互交错，虚拟机就必须维护一个列表记录那些内存可用，分配时从列表中找一块足够大的内存划分给对象实例，然后刷新列表<ul><li>内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），若使用TLAB，这个过程可提前在TLAB分配时进行</li><li>对对象进行设置，例如对象是那个类的实例，如何找到类的元数据信息，对象的哈希码等，存放在对象的对象头</li><li>以上完成后，从虚拟机计角度，对象已经创建，但是从java程序角度来看，对象创建刚开始，执行<init>方法后，按照程序员的意愿初始化后，对象才正真创建</init></li></ul></li></ul></li></ul></li><li>对象的内存布局<ul><li><strong>对象头（Header）</strong><ul><li>Mark Word，用于存储对象自身本身运行时的数据（哈希表，GC分代年龄，线程持有的锁等）</li><li>类型指针，对象指向它的类元数据的指针，虚拟机通过这个来确定对象是那个类型的实例（不是所有虚拟机都必须在对象数据中保留类型指针，即查找对象不一定要经过对象本身），java数组还需要一个记录数组长度的数据</li></ul></li><li><strong>实例数据（Instance Data）</strong><ul><li>对象真正存储的有效信息，即代码中定义的各种类型的字段内容</li><li>这部分存储顺序受到虚拟机分配策略参数（FieldsAllocationStyle）和java源码定义顺序影响</li></ul></li><li>对齐填充（Padding）<br><em>这部分不是必要存在</em><ul><li>起占位符作用，对象起始地址必须是8字节的整数倍，当没有8字节整数倍时，就填充</li></ul></li></ul></li><li><strong>对象访问地址</strong><br><strong>java程序通过栈中的reference类型数据来操作堆上的具体对象，reference类型被规定是一个指向对象的引用</strong><ul><li><strong>句柄访问</strong>，java堆划分一块内存做为句柄池，reference存储句柄地址，句柄包含对象实例和类型数据各自的具体地址信息（稳定）<br><img src="/images/java内存区域与内存溢出异常/1.png" alt=" "></li><li><strong>直接访问</strong>，reference存储是对象地址（快速）<br><img src="/images/java内存区域与内存溢出异常/3.png" alt=" "></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/java内存区域与内存溢出异常/2.png&quot; alt=&quot; &quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
      <category term="JVM" scheme="https://mrnoknow.github.io/categories/JAVA/JVM/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在vm下 Ubuntu server网络配置</title>
    <link href="https://mrnoknow.github.io/2016/04/30/%E5%9C%A8vm%E4%B8%8B%20Ubuntu%20server%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://mrnoknow.github.io/2016/04/30/在vm下 Ubuntu server网络配置/</id>
    <published>2016-04-30T07:31:00.000Z</published>
    <updated>2019-03-18T07:53:04.663Z</updated>
    
    <content type="html"><![CDATA[<p>在VM（win7）下Ubuntu server的网络配置，仅提供我解决的方式。（也是查阅许多资料得到的）</p><p><img src="/images/在vm下 Ubuntu server网络配置/1.jpg" alt="本机分配IP"></p><p>我的IPV4 地址首选地址为   <em>192.168.254.1</em>  ,所以我将虚拟机中NET连接的网关设置为 <em>192.168.254.1</em>。</p><p>如图：<br>            <img src="/images/在vm下 Ubuntu server网络配置/2.png" alt="设置vm的NET网关"></p><p>当然不要忘记把子网IP(network)改成 <em>192.168.254.0</em>;保证在同一网段。</p><p>如图:<br><img src="/images/在vm下 Ubuntu server网络配置/3.jpg" alt="设置vm的NET子网IP"></p><p>之后设置Ubuntu server 中的IP，网关，network，DNS。</p><ul><li>设置IP、网关等。sudo vim /etc/network/interfaces，设置如下<br><img src="/images/在vm下 Ubuntu server网络配置/5.png" alt="设置Ubuntu IP 网关 network 网关 DNS"><br>在此这个IP 也是有范围的,查看 <em>DHCP设置</em><br><img src="/images/在vm下 Ubuntu server网络配置/4.png" alt="IP范围"></li></ul><p>我们看到我的可用IP地址为 <em>192.168.199.254.128~192.168.199.254.254</em>,所以我们设置的IP地址必须为此范围内。</p><ul><li><p>设置hosts文件中的IP,sudo vim /etc/hosts<br><img src="/images/在vm下 Ubuntu server网络配置/6.png" alt="IP设置"><br>此地址与1步骤中的IP一致。</p></li><li><p>设置DNS服务器,sudo vim /etc/resolv.conf<br><img src="/images/在vm下 Ubuntu server网络配置/7.png" alt="DNS服务器设置"></p></li></ul><p>完成以上，重启服务就OK了。</p><p><strong> 在这里着重提醒一下，网关和dns服务器尽量填写首选ip地址（192.168.254.1）不然在后面会出现host unreachable这个问题 </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在VM（win7）下Ubuntu server的网络配置，仅提供我解决的方式。（也是查阅许多资料得到的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/在vm下 Ubuntu server网络配置/1.jpg&quot; alt=&quot;本机分配IP&quot;&gt;&lt;/p&gt;
&lt;p&gt;我的IPV4 地
      
    
    </summary>
    
      <category term="虚拟机" scheme="https://mrnoknow.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Ubuntu server" scheme="https://mrnoknow.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/Ubuntu-server/"/>
    
    
      <category term="other" scheme="https://mrnoknow.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>编码问题</title>
    <link href="https://mrnoknow.github.io/2016/04/14/%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://mrnoknow.github.io/2016/04/14/编码问题/</id>
    <published>2016-04-14T09:18:27.000Z</published>
    <updated>2019-03-18T07:53:04.665Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>java.java-------&gt;GBK(操作系统)------&gt;UNICODE(.<span class="keyword">class</span>   JDK)最后为UNICODE的编码.<span class="keyword">class</span></span><br><span class="line"><span class="number">2.</span>servlets-----&gt;GBK(WEB调用JSP编译器，查看字符编码，JSP编译器调用JDK用JVM的默认编码格式(操作系统)编译成临时Servlet类)--------&gt;UNICODE(临时文件夹)</span><br><span class="line"><span class="number">3.</span>console-----&gt;GBK------&gt;UNICODE-------&gt;UNICODE(输入转化)-------&gt;GBK(输出转化)避免出现乱码</span><br><span class="line"><span class="number">4.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="计算机系统" scheme="https://mrnoknow.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="other" scheme="https://mrnoknow.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>jsp的结构图（自己理解）</title>
    <link href="https://mrnoknow.github.io/2016/04/14/jsp%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%88%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://mrnoknow.github.io/2016/04/14/jsp的结构图（自己理解）/</id>
    <published>2016-04-14T09:10:22.000Z</published>
    <updated>2019-03-18T07:53:04.663Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">结构图：</span><br><span class="line">webapps</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">  examples</span><br><span class="line">  |      |</span><br><span class="line">  |      |</span><br><span class="line"> html   WEB-INF---web.xml  </span><br><span class="line"> jsp        |</span><br><span class="line">            |</span><br><span class="line">          classes</span><br><span class="line">@@将jar包放进JDK的jre/<span class="class"><span class="keyword">lib</span>/<span class="title">ext</span>(<span class="title">servlet</span>-<span class="title">api</span>.<span class="title">jar</span>)</span></span><br><span class="line">   否则不能解析.java .<span class="keyword">class</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.建立对象</span><br><span class="line"><span class="number">2</span>.建立post的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
      <category term="jsp" scheme="https://mrnoknow.github.io/categories/JAVA/jsp/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>oracle 11g常用命令</title>
    <link href="https://mrnoknow.github.io/2016/04/14/oracle-11g%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://mrnoknow.github.io/2016/04/14/oracle-11g常用命令/</id>
    <published>2016-04-14T09:08:27.000Z</published>
    <updated>2019-03-18T07:53:04.663Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t1;（t1是表的名字）删除表空间</span><br><span class="line"></span><br><span class="line">flashback table t1 to before <span class="keyword">drop</span>；（t1是表的名字）找回删除的表空间</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">year</span> <span class="built_in">int</span> 添加列</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">year</span> <span class="built_in">int</span></span><br><span class="line">)       创建表空间</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">year</span>;   删除列</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'fun'</span>;  删除列中的name 为fun的数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student 在不删除表空间的情况下，删除所有列</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="sql" scheme="https://mrnoknow.github.io/categories/sql/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="other" scheme="https://mrnoknow.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>git命令(因为经常忘记，所以记录下)</title>
    <link href="https://mrnoknow.github.io/2016/04/14/git%E6%B7%BB%E5%8A%A0repository%E5%91%BD%E4%BB%A4-%E5%9B%A0%E4%B8%BA%E7%BB%8F%E5%B8%B8%E5%BF%98%E8%AE%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E8%AE%B0%E5%BD%95%E4%B8%8B/"/>
    <id>https://mrnoknow.github.io/2016/04/14/git添加repository命令-因为经常忘记，所以记录下/</id>
    <published>2016-04-14T09:03:21.000Z</published>
    <updated>2019-03-18T07:53:04.662Z</updated>
    
    <content type="html"><![CDATA[<p>1.git init<br>2.git remote add origin -ssh<br>3.git add .<br>4.git commit -m “First”<br>5.git push origin master</p><p><strong>在创建密钥时，一定要进入<code>cd /</code>中，然后一直回车就行了，有时会出各种幺蛾子</strong></p><ul><li>密钥创建： ssh-keygen -t rsa -C “your_email@example.com”</li><li>密钥生成在 ~/.ssh 中，有2个id_rsa与id_rsa.pub，将id_rsa.pub中的key值复制道github中ssh key值就行了</li><li>查看远程仓库：$ git remote -v</li><li>添加远程仓库：$ git remote add [name] [url]</li><li>删除远程仓库：$ git remote rm [name]</li><li>拉取远程仓库：$ git pull [remoteName] [localBranchName]</li><li>推送远程仓库：$ git push [remoteName] [localBranchName]</li><li>查看本地分支：$ git branch</li><li>查看远程分支：$ git branch -r</li><li>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</li><li>切换分支：$ git checkout [name]</li></ul><p><code>remoteName</code> 就是git remote add [name] [url]中的<code>name</code><br>origin    git@github.com:Mrnoknow/mrnoknow.github.io.git (fetch)<br>origin    git@github.com:Mrnoknow/mrnoknow.github.io.git (push)<br>origin 就是对应的remoteName，也就是remote add [name] 中的name，<br>localBranchName 就是远程仓库的分支名字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.git init&lt;br&gt;2.git remote add origin -ssh&lt;br&gt;3.git add .&lt;br&gt;4.git commit -m “First”&lt;br&gt;5.git push origin master&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在创建密钥时，一定
      
    
    </summary>
    
      <category term="git" scheme="https://mrnoknow.github.io/categories/git/"/>
    
    
      <category term="other" scheme="https://mrnoknow.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式遍历java集合</title>
    <link href="https://mrnoknow.github.io/2016/04/09/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86java%E9%9B%86%E5%90%88/"/>
    <id>https://mrnoknow.github.io/2016/04/09/Lambda表达式遍历java集合/</id>
    <published>2016-04-09T14:38:57.000Z</published>
    <updated>2019-03-18T07:53:04.660Z</updated>
    
    <content type="html"><![CDATA[<p><em>以下为java 8才能实现</em></p><h2 id="Iterable接口实现"><a href="#Iterable接口实现" class="headerlink" title="Iterable接口实现"></a>Iterable接口实现</h2><p>Iterable（不是Iterator，这里需要说:<strong>Iterable接口是Collection接口的父接口</strong>）<br>新增了一个forEach（Consumer action）默认方法，Collection直接调用改方法而该方法需要函数式<br>接口(是不是函数式编程，一脸懵逼~可能不是)。<br>需要说的是:<strong>Consumer的accept（T t）方法（是该接口的唯一方法），因为Consumer事函数式接口。</strong></p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">noknow</span><span class="selector-class">.forEach</span>(<span class="selector-tag">obj-</span>&gt;<span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>("<span class="selector-tag">Your</span> <span class="selector-tag">name</span><span class="selector-pseudo">:"+obj))</span>;</span><br></pre></td></tr></table></figure><h2 id="Iterator（迭代器）接口实现"><a href="#Iterator（迭代器）接口实现" class="headerlink" title="Iterator（迭代器）接口实现"></a>Iterator（迭代器）接口实现</h2><p>Iterator新增forEachRemaining（Consumer action）方法<br>此方法与Iterable接口不同的是集合必须获取Iterator迭代器</p><h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Iterator </span>mr<span class="symbol">=noknow</span>.<span class="keyword">iterator();</span></span><br><span class="line"><span class="keyword">mr.forEachRemaining(obj-&gt;System.out.println("Your </span>name:<span class="string">"+obj));</span></span><br></pre></td></tr></table></figure><p><strong>课外扩展：Iterator为快速失败(fail-fast)机制，就是如果有多线程对同一个集合进行操作，如果有<br>一个线程进行了修改操作，程序就会发生异常，而不会使用修改的值，以此避免共享资源潜在的危险。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;以下为java 8才能实现&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Iterable接口实现&quot;&gt;&lt;a href=&quot;#Iterable接口实现&quot; class=&quot;headerlink&quot; title=&quot;Iterable接口实现&quot;&gt;&lt;/a&gt;Iterable接口实现&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA编写一个简易的爬虫(爬取网页链接)</title>
    <link href="https://mrnoknow.github.io/2016/04/08/JAVA%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
    <id>https://mrnoknow.github.io/2016/04/08/JAVA编写一个简易的爬虫-爬取网页链接/</id>
    <published>2016-04-08T09:41:05.000Z</published>
    <updated>2019-03-18T07:53:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>这个简易的爬虫需要jsoup包，一个java的第三方包</p><h2 id="jsoup包有什么作用（在这个简易的爬虫程序中）？"><a href="#jsoup包有什么作用（在这个简易的爬虫程序中）？" class="headerlink" title="jsoup包有什么作用（在这个简易的爬虫程序中）？"></a>jsoup包有什么作用（在这个简易的爬虫程序中）？</h2><p>在这个简易的程序中，所需要的是jsoup包中的<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.jsoup</span><span class="selector-class">.Jsoup</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.jsoup</span><span class="selector-class">.nodes</span><span class="selector-class">.Document</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.jsoup</span><span class="selector-class">.nodes</span><span class="selector-class">.Element</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.jsoup</span><span class="selector-class">.select</span><span class="selector-class">.Elements</span>;</span><br><span class="line">这几个类。</span><br><span class="line">主要是解析网页中的标签，直接抽取网页链接</span><br></pre></td></tr></table></figure></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocOperate</span> </span>&#123;</span><br><span class="line"><span class="type">UrlOperate</span> urlGet=new <span class="type">UrlOperate</span>();</span><br><span class="line"><span class="keyword">public</span> void <span class="type">LinkAcquisition</span>(<span class="type">String</span> url) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;<span class="comment">//链接获取</span></span><br><span class="line">urlGet.<span class="type">ArrayAdd</span>(url);</span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(url);</span><br><span class="line"><span class="type">Document</span> doc;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">doc = <span class="type">Jsoup</span>.connect(url).timeout(<span class="number">5000</span>).<span class="keyword">get</span>();<span class="comment">//解析网页内容，设置连接时间</span></span><br><span class="line"> <span class="type">Elements</span> links = doc.select(<span class="string">"a[href]"</span>);<span class="comment">//获取所有网页链接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Element</span> link : links) &#123;</span><br><span class="line">    </span><br><span class="line">          <span class="type">String</span> linkHref = link.attr(<span class="string">"abs:href"</span>);<span class="comment">//获取单个链接</span></span><br><span class="line">          <span class="keyword">if</span>(linkHref!=<span class="string">""</span>)&#123;</span><br><span class="line">               <span class="comment">//System.out.println(linkHref);</span></span><br><span class="line">               urlGet.<span class="type">LinkedAdd</span>(linkHref);&#125;<span class="comment">//添加到待爬取链接</span></span><br><span class="line">          &#125;</span><br><span class="line">         <span class="type">LinkRepeatJudgment</span>();<span class="comment">//执行链接重复的判断</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;<span class="comment">//如果出现异常，就直接执行链接重复判断</span></span><br><span class="line"><span class="type">LinkRepeatJudgment</span>();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> void <span class="type">LinkRepeatJudgment</span>() <span class="keyword">throws</span> <span class="type">IOException</span> &#123;<span class="comment">//链接重复判断</span></span><br><span class="line"><span class="keyword">if</span>(!urlGet.<span class="type">IsEmpty</span>())&#123;<span class="comment">//如果待爬取链接不为空</span></span><br><span class="line"><span class="type">String</span> url=urlGet.<span class="type">GetUrl</span>();<span class="comment">//获取第一个待爬取链接</span></span><br><span class="line">urlGet.<span class="type">Remove</span>(url);<span class="comment">//移除待爬取链接的第一个</span></span><br><span class="line"><span class="keyword">if</span>(urlGet.<span class="type">CompareUrl</span>(url))&#123;<span class="comment">//如果该链接被爬取，继续执行此方法</span></span><br><span class="line"><span class="comment">//System.out.println(url);</span></span><br><span class="line"><span class="type">LinkRepeatJudgment</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;否则执行链接重复判断</span><br><span class="line">    </span><br><span class="line">        <span class="type">LinkAcquisition</span>(url);&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"game over"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是工具类，主要用于抓取网页链接。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> class UrlOperate &#123;</span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;<span class="keyword">String</span>&gt; linked=<span class="keyword">new</span> LinkedList&lt;<span class="keyword">String</span>&gt;();<span class="comment">//待爬取链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;<span class="keyword">String</span>&gt; arry=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();<span class="comment">//以爬取链接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> LinkedAdd(<span class="keyword">String</span> url)&#123;<span class="comment">//添加待爬取链接</span></span><br><span class="line">linked.<span class="built_in">add</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Remove(<span class="keyword">String</span> url)&#123;<span class="comment">//爬取链接移除</span></span><br><span class="line"></span><br><span class="line">linked.remove(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> GetUrl()&#123;<span class="comment">//得到待爬取第一个链接</span></span><br><span class="line"><span class="keyword">return</span> linked.getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> IsEmpty()&#123;<span class="comment">//判断待爬取链接是否为空</span></span><br><span class="line"><span class="keyword">return</span> linked.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkedList&lt;<span class="keyword">String</span>&gt; getHash()&#123;</span><br><span class="line"><span class="keyword">return</span> linked;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ArrayAdd(<span class="keyword">String</span> url)&#123;<span class="comment">//以爬取链接的添加</span></span><br><span class="line">arry.<span class="built_in">add</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> CompareUrl(<span class="keyword">String</span> url)&#123;<span class="comment">//判断将爬取链接是否已存在于以爬取链接中</span></span><br><span class="line"><span class="keyword">return</span> arry.contains(url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码为网页链接的存取以及判断是否被爬取，对象类。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spider</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) throws IOException&#123;</span><br><span class="line"><span class="keyword">String</span> line=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">String</span> url=<span class="string">"http://mrnoknow.github.io/"</span>;</span><br><span class="line">DocOperate operate=<span class="keyword">new</span> <span class="type">DocOperate</span>();</span><br><span class="line">operate.LinkAcquisition(url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个简易的爬虫需要jsoup包，一个java的第三方包&lt;/p&gt;
&lt;h2 id=&quot;jsoup包有什么作用（在这个简易的爬虫程序中）？&quot;&gt;&lt;a href=&quot;#jsoup包有什么作用（在这个简易的爬虫程序中）？&quot; class=&quot;headerlink&quot; title=&quot;jsoup包有
      
    
    </summary>
    
      <category term="JAVA" scheme="https://mrnoknow.github.io/categories/JAVA/"/>
    
    
      <category term="Coding" scheme="https://mrnoknow.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>符号扩展和零扩展（深入理解计算机系统）</title>
    <link href="https://mrnoknow.github.io/2016/03/26/%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E5%92%8C%E9%9B%B6%E6%89%A9%E5%B1%95%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <id>https://mrnoknow.github.io/2016/03/26/符号扩展和零扩展（深入理解计算机系统）/</id>
    <published>2016-03-26T06:40:43.000Z</published>
    <updated>2019-03-18T07:53:04.665Z</updated>
    
    <content type="html"><![CDATA[<p>不同字长的整数之间的转换有2种<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">符号扩展（有符号数）</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">零扩展（无符号数）</span><br></pre></td></tr></table></figure></p><h2 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short x=-1 //二进制补码：10000001；</span><br><span class="line">int y=x;   //二进制补码：1111111110000001；</span><br></pre></td></tr></table></figure><p>上面就是二进制符号扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short x=-1 //二进制补码：10000001；</span><br><span class="line">unsigned int y=x;   //二进制补码：0000000010000001；</span><br></pre></td></tr></table></figure><p>零扩展。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不同字长的整数之间的转换有2种&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
      <category term="计算机系统" scheme="https://mrnoknow.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="读书笔记" scheme="https://mrnoknow.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="二进制编码" scheme="https://mrnoknow.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
